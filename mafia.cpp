// ============================================================
// Mafia 조직도 문제
// 목적: 조직원들을 부하 수, 깊이, 이름 순으로 정렬하여 출력
// ============================================================

#include <iostream>
#include <unordered_map>  // 이름 -> 인덱스 매핑을 위한 해시맵 (O(1) 탐색)
#include <vector>         // 동적 배열
#include <string>         // 사람 이름 저장
#include <algorithm>      // sort() 함수 사용
using namespace std;

// ============================================================
// 전역 변수 선언부
// ============================================================
int n;                              // 조직원 총 인원 수
int root;                           // 루트 노드(최고 보스)의 인덱스

vector<string> names;               // 각 인덱스에 해당하는 사람 이름 저장
vector<vector<int>> children;       // 각 노드(상사)의 직속 부하들 목록 (트리 구조)
vector<int> subordinates;           // 각 노드의 전체 부하 수 (직속 + 간접 부하 모두 포함)
vector<int> depth;                  // 각 노드의 깊이 (루트=0, 한 단계 아래=1, ...)
vector<bool> hasParent;             // 각 노드가 상사를 가지는지 여부 (루트 찾기용)

// ============================================================
// calcSub: 각 노드의 전체 부하 수를 재귀적으로 계산
// ============================================================
// 파라미터: node - 부하 수를 계산할 노드의 인덱스
// 반환값: 해당 노드의 전체 부하 수
//
// 동작 원리:
// 1. 자식 노드 각각에 대해 재귀적으로 부하 수 계산
// 2. 각 자식의 부하 수 + 1(자식 본인)을 모두 합산
// 3. 계산된 값을 subordinates[node]에 저장하고 반환
//
// 예시: A의 자식이 B, C이고, B의 부하가 2명, C의 부하가 3명이면
//       A의 부하 = (1+2) + (1+3) = 7명
// ============================================================
int calcSub(int node){
    int count=0;                          // 부하 수 누적 변수
    for(int child:children[node])         // 모든 직속 부하에 대해
        count+=1+calcSub(child);          // 자식 1명 + 자식의 부하들 합산
    return subordinates[node]=count;      // 계산 결과 저장 및 반환
}

// ============================================================
// calcDepth: 각 노드의 깊이(계층)를 재귀적으로 계산
// ============================================================
// 파라미터:
//   node - 깊이를 계산할 노드의 인덱스
//   d    - 현재 노드의 깊이 값
//
// 동작 원리:
// 1. 현재 노드의 깊이를 d로 설정
// 2. 모든 자식 노드에 대해 깊이 d+1로 재귀 호출
// 3. 루트부터 시작하면 모든 노드의 깊이가 설정됨
//
// 예시: 루트(깊이 0) -> 직속부하(깊이 1) -> 그 아래(깊이 2) ...
// ============================================================
void calcDepth(int node,int d){
    depth[node]=d;                        // 현재 노드의 깊이 설정
    for(int child:children[node])         // 모든 자식 노드에 대해
        calcDepth(child,d+1);             // 깊이를 1 증가시켜 재귀 호출
}

// ============================================================
// cmp: 두 노드를 정렬 기준에 따라 비교하는 함수
// ============================================================
// 파라미터: a, b - 비교할 두 노드의 인덱스
// 반환값: a가 b보다 앞에 와야 하면 true, 아니면 false
//
// 정렬 우선순위:
// 1순위: 부하 수가 많은 사람이 앞 (내림차순)
// 2순위: 깊이가 얕은 사람이 앞 (오름차순) - 높은 직급이 앞
// 3순위: 이름이 사전순으로 빠른 사람이 앞 (오름차순)
//
// 예시: A(부하10명, 깊이1), B(부하10명, 깊이2) -> A가 앞
//       C(부하5명), D(부하8명) -> D가 앞
// ============================================================
bool cmp(int a,int b){
    // 1순위: 부하 수 비교 (많을수록 앞)
    if(subordinates[a]!=subordinates[b])
        return subordinates[a]>subordinates[b];

    // 2순위: 깊이 비교 (얕을수록 앞, 즉 상위 직급이 앞)
    if(depth[a]!=depth[b])
        return depth[a]<depth[b];

    // 3순위: 이름 사전순 비교
    return names[a]<names[b];
}

// ============================================================
// main: 메인 함수 - 전체 프로그램의 실행 흐름
// ============================================================
int main(){
    // ============================================================
    // STEP 0: 입출력 최적화
    // ============================================================
    ios_base::sync_with_stdio(false);     // C stdio와 동기화 해제 (속도 향상)
    cin.tie(nullptr);                     // cin과 cout 분리 (속도 향상)

    // ============================================================
    // STEP 1: 입력 받기 및 자료구조 초기화
    // ============================================================
    cin>>n;                               // 조직원 수 입력

    // nameIdx: 이름을 키로, 인덱스를 값으로 저장하는 해시맵
    // 목적: 같은 이름이 여러 번 나와도 동일한 인덱스 사용
    unordered_map<string,int> nameIdx;

    // 벡터들 크기 미리 할당 (메모리 재할당 방지로 성능 향상)
    names.reserve(n);                     // 이름 저장 공간 예약
    children.resize(n);                   // 각 노드의 자식 목록
    subordinates.resize(n);               // 각 노드의 부하 수
    depth.resize(n);                      // 각 노드의 깊이
    hasParent.resize(n,false);            // 초기값 false로 초기화

    // ============================================================
    // STEP 2: 관계 입력 처리 (n-1개의 상하관계)
    // ============================================================
    // n명의 사람이 있으면 n-1개의 관계로 트리가 완성됨
    for(int i=0;i<n-1;i++){
        string person,boss;               // person은 boss의 부하
        cin>>person>>boss;

        // person이 처음 등장하는 이름이면 인덱스 부여
        if(!nameIdx.count(person)){
            nameIdx[person]=names.size(); // 현재 names 크기를 새 인덱스로 사용
            names.push_back(person);      // 이름 목록에 추가
        }

        // boss가 처음 등장하는 이름이면 인덱스 부여
        if(!nameIdx.count(boss)){
            nameIdx[boss]=names.size();
            names.push_back(boss);
        }

        // 인덱스 가져오기
        int pIdx=nameIdx[person];         // person의 인덱스
        int bIdx=nameIdx[boss];           // boss의 인덱스

        // 트리 구조 구축
        children[bIdx].push_back(pIdx);   // boss의 자식 목록에 person 추가
        hasParent[pIdx]=true;             // person은 상사가 있음 표시
    }

    // ============================================================
    // STEP 3: 루트 노드(최고 보스) 찾기
    // ============================================================
    // 상사가 없는 사람(hasParent[i]==false)이 루트
    for(int i=0;i<n;i++)
        if(!hasParent[i]){
            root=i;                       // 루트 인덱스 저장
            break;                        // 루트는 하나뿐이므로 찾으면 종료
        }

    // ============================================================
    // STEP 4: 각 노드의 부하 수와 깊이 계산
    // ============================================================
    calcSub(root);                        // 루트부터 시작해 모든 노드의 부하 수 계산
    calcDepth(root,0);                    // 루트의 깊이를 0으로 시작해 모든 노드 깊이 계산

    // ============================================================
    // STEP 5: 인덱스 배열 생성 및 정렬
    // ============================================================
    // indices: 0부터 n-1까지의 인덱스를 담은 배열
    // 이 배열을 정렬하면 정렬 기준에 따른 순서를 얻을 수 있음
    vector<int> indices(n);
    for(int i=0;i<n;i++)
        indices[i]=i;                     // indices = [0, 1, 2, ..., n-1]

    // cmp 함수를 기준으로 indices 정렬
    // 결과: 부하 많은순 -> 깊이 얕은순 -> 이름 사전순
    sort(indices.begin(),indices.end(),cmp);

    // ============================================================
    // STEP 6: 정렬된 순서대로 이름 출력
    // ============================================================
    for(int idx:indices)
        cout<<names[idx]<<'\n';           // 정렬된 인덱스 순서대로 이름 출력
}

// ============================================================
// 전체 알고리즘 요약
// ============================================================
//
// 1. 입력 처리
//    - n-1개의 상하관계를 읽어 트리 구조 생성
//    - unordered_map으로 이름->인덱스 매핑 (O(1) 탐색)
//
// 2. 루트 찾기
//    - hasParent 배열로 상사가 없는 노드 찾기
//
// 3. 부하 수 계산 (calcSub)
//    - 재귀적으로 각 노드의 모든 부하(직속+간접) 수 계산
//    - 시간복잡도: O(n) - 모든 노드를 한 번씩 방문
//
// 4. 깊이 계산 (calcDepth)
//    - 재귀적으로 각 노드의 계층 레벨 계산
//    - 시간복잡도: O(n) - 모든 노드를 한 번씩 방문
//
// 5. 정렬
//    - 인덱스 배열을 커스텀 비교 함수로 정렬
//    - 시간복잡도: O(n log n)
//
// 6. 출력
//    - 정렬된 순서대로 이름 출력
//    - 시간복잡도: O(n)
//
// ============================================================
// 전체 시간복잡도: O(n log n)
// 전체 공간복잡도: O(n)
// ============================================================
//
// ============================================================
// 핵심 자료구조
// ============================================================
// 1. unordered_map<string,int> nameIdx
//    - 이름을 인덱스로 빠르게 변환 (O(1))
//
// 2. vector<vector<int>> children
//    - 트리의 부모-자식 관계 저장
//    - children[i] = i번 노드의 직속 부하 목록
//
// 3. vector<int> subordinates
//    - subordinates[i] = i번 노드의 전체 부하 수
//
// 4. vector<int> depth
//    - depth[i] = i번 노드의 깊이 (루트=0)
//
// 5. vector<bool> hasParent
//    - hasParent[i] = i번 노드가 상사를 가지는가?
//    - 루트 찾기에 사용
// ============================================================
