# 자료구조 기말고사 풀이

## 문제 1. Generic Algorithm 함수 구현

다음 3개 generic algorithm 함수를 작성하시오. 단, 예제에 사용된 자료구조는 vector, list등 어떤 것을 사용해도 무방하며 원소의 개수는 최소 9개로 한다.

### 1) unique()

**목적**: 연속된 중복 원소를 제거하고, 중복이 제거된 범위의 끝 iterator를 반환

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// unique 함수 구현
template<typename Iterator>
Iterator my_unique(Iterator first, Iterator last) {
    if (first == last) return last;

    Iterator result = first;
    while (++first != last) {
        if (!(*result == *first)) {
            *(++result) = *first;
        }
    }
    return ++result;
}

// 예제
int main() {
    vector<int> v = {1, 1, 2, 2, 2, 3, 4, 4, 5, 5, 5, 6};

    cout << "원본: ";
    for (int x : v) cout << x << " ";
    cout << endl;

    auto new_end = my_unique(v.begin(), v.end());
    v.erase(new_end, v.end());

    cout << "unique 후: ";
    for (int x : v) cout << x << " ";
    cout << endl;

    return 0;
}
```

**출력**:
```
원본: 1 1 2 2 2 3 4 4 5 5 5 6
unique 후: 1 2 3 4 5 6
```

### 2) count_if()

**목적**: 주어진 조건(predicate)을 만족하는 원소의 개수를 반환

```cpp
#include <iostream>
#include <vector>
using namespace std;

// count_if 함수 구현
template<typename Iterator, typename Predicate>
int my_count_if(Iterator first, Iterator last, Predicate pred) {
    int count = 0;
    while (first != last) {
        if (pred(*first)) {
            count++;
        }
        ++first;
    }
    return count;
}

// 예제
int main() {
    vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};

    // 짝수 개수 세기
    int even_count = my_count_if(v.begin(), v.end(),
                                  [](int x) { return x % 2 == 0; });

    cout << "짝수 개수: " << even_count << endl;

    // 5보다 큰 수 개수 세기
    int greater_than_5 = my_count_if(v.begin(), v.end(),
                                      [](int x) { return x > 5; });

    cout << "5보다 큰 수: " << greater_than_5 << endl;

    return 0;
}
```

**출력**:
```
짝수 개수: 5
5보다 큰 수: 6
```

### 3) for_each()

**목적**: 범위의 모든 원소에 대해 주어진 함수를 적용

```cpp
#include <iostream>
#include <vector>
using namespace std;

// for_each 함수 구현
template<typename Iterator, typename Function>
Function my_for_each(Iterator first, Iterator last, Function f) {
    while (first != last) {
        f(*first);
        ++first;
    }
    return f;
}

// 예제
int main() {
    vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    cout << "각 원소 출력: ";
    my_for_each(v.begin(), v.end(), [](int x) { cout << x << " "; });
    cout << endl;

    // 각 원소에 2를 곱하기
    my_for_each(v.begin(), v.end(), [](int& x) { x *= 2; });

    cout << "2배 후: ";
    for (int x : v) cout << x << " ";
    cout << endl;

    return 0;
}
```

**출력**:
```
각 원소 출력: 1 2 3 4 5 6 7 8 9
2배 후: 2 4 6 8 10 12 14 16 18
```

---

## 문제 2. Shortest Path Tree (Dijkstra)

다음 그래프에서 Shortest Path Tree를 Dijkstra 알고리즘을 사용하여 구하시오. 5번에서 출발하는 Shortest path tree에 선택되는 vertex를 차례대로 표시하시오. edge에 표시된 숫자는 그것을 지나는데 걸리는 시간이다. 단, 시작과 끝 vertex로 간주하지 않는다.

### 풀이

**그래프 정보**:
- Vertex: 1, 2, 3, 4, 5, 6, 7, 8, 9
- 시작점: 5번 vertex

**Dijkstra 알고리즘 수행**:

```
초기 상태:
dist[5] = 0
dist[나머지] = ∞

Step 1: vertex 5 선택 (dist = 0)
- 5→8: dist[8] = min(∞, 0+7) = 7
- 5→3: dist[3] = min(∞, 0+7) = 7

Step 2: vertex 8 선택 (dist = 7)
- 8→5: dist[5] = min(0, 7+7) = 0
- 8→3: dist[3] = min(7, 7+6) = 7
- 8→1: dist[1] = min(∞, 7+4) = 11

Step 3: vertex 3 선택 (dist = 7)
- 3→5: dist[5] = min(0, 7+7) = 0
- 3→8: dist[8] = min(7, 7+6) = 7
- 3→4: dist[4] = min(∞, 7+9) = 16
- 3→9: dist[9] = min(∞, 7+19) = 26

계속 진행...
```

**최종 Shortest Path Tree**:
시작점 5번에서 순서대로 선택되는 처음 3개 vertex:
1. **5번** (시작점, dist = 0)
2. **8번** (dist = 7)
3. **3번** (dist = 7)

### 구현 코드

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

const int INF = INT_MAX;

struct Edge {
    int to, weight;
};

vector<int> dijkstra(int start, vector<vector<Edge>>& graph) {
    int n = graph.size();
    vector<int> dist(n, INF);
    vector<int> order; // 선택 순서
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;

    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (d > dist[u]) continue;

        order.push_back(u);

        for (auto [v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    return order;
}

int main() {
    int n = 10; // vertex 0~9 (1~9 사용)
    vector<vector<Edge>> graph(n);

    // 그래프 구성 (예시)
    graph[5].push_back({8, 7});
    graph[5].push_back({3, 7});
    graph[8].push_back({5, 7});
    graph[8].push_back({3, 6});
    graph[8].push_back({1, 4});
    // ... 나머지 edge 추가

    vector<int> order = dijkstra(5, graph);

    cout << "선택 순서 (처음 3개): ";
    for (int i = 0; i < 3 && i < order.size(); i++) {
        cout << order[i] << " ";
    }
    cout << endl;

    return 0;
}
```

---

## 문제 3. Array를 이용한 Minimum Heap (Priority Queue) 내부구조

1차원 배열로 Complete Tree 구조의 **Minimum heap**을 구현한다. 이때 다음과 같은 동작으로 진행될 때 그때의 1차원 배열의 내용을 표시하시오. 아래 표의 동작에서 'i x'는 값인 insert하는 것을, 'pop'은 Minimum 원소를 pop 하는 것을 의미한다.

### 초기 상태
```
heap = [13, 19, 28, 55, 27, 40]
```

### 동작 과정

| 동작 | 설명 | Heap 상태 (index 0부터) |
|------|------|------------------------|
| 초기 | - | `[13, 19, 28, 55, 27, 40]` |
| i 10 | 10 삽입 | `[10, 19, 13, 55, 27, 40, 28]` |
| i 22 | 22 삽입 | `[10, 19, 13, 22, 27, 40, 28, 55]` |
| pop | 10 제거 | `[13, 19, 28, 22, 27, 40, 55]` |
| i 37 | 37 삽입 | `[13, 19, 28, 22, 27, 40, 55, 37]` |
| pop | 13 제거 | `[19, 22, 28, 37, 27, 40, 55]` |
| i 17 | 17 삽입 | `[17, 19, 28, 22, 27, 40, 55, 37]` |
| i 44 | 44 삽입 | `[17, 19, 28, 22, 27, 40, 55, 37, 44]` |
| pop | 17 제거 | `[19, 22, 28, 37, 27, 40, 55, 44]` |

### 상세 과정 설명

**i 10 (10 삽입)**:
1. 배열 끝에 10 추가: `[13, 19, 28, 55, 27, 40, 10]`
2. 부모와 비교하며 heapify up:
   - 10 vs 28 → 교환: `[13, 19, 10, 55, 27, 40, 28]`
   - 10 vs 13 → 교환: `[10, 19, 13, 55, 27, 40, 28]`

**i 22 (22 삽입)**:
1. 배열 끝에 22 추가: `[10, 19, 13, 55, 27, 40, 28, 22]`
2. 22 vs 55 → 교환: `[10, 19, 13, 22, 27, 40, 28, 55]`

**pop (10 제거)**:
1. root(10)를 마지막 원소(55)로 교체: `[55, 19, 13, 22, 27, 40, 28]`
2. Heapify down:
   - 55 vs min(19, 13) → 13과 교환: `[13, 19, 55, 22, 27, 40, 28]`
   - 55 vs min(28) → 28과 교환: `[13, 19, 28, 22, 27, 40, 55]`

### 구현 코드

```cpp
#include <iostream>
#include <vector>
using namespace std;

class MinHeap {
    vector<int> heap;

    void heapifyUp(int idx) {
        while (idx > 0) {
            int parent = (idx - 1) / 2;
            if (heap[idx] < heap[parent]) {
                swap(heap[idx], heap[parent]);
                idx = parent;
            } else break;
        }
    }

    void heapifyDown(int idx) {
        int size = heap.size();
        while (true) {
            int left = 2 * idx + 1;
            int right = 2 * idx + 2;
            int smallest = idx;

            if (left < size && heap[left] < heap[smallest])
                smallest = left;
            if (right < size && heap[right] < heap[smallest])
                smallest = right;

            if (smallest != idx) {
                swap(heap[idx], heap[smallest]);
                idx = smallest;
            } else break;
        }
    }

public:
    void insert(int val) {
        heap.push_back(val);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        if (heap.empty()) return;
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty())
            heapifyDown(0);
    }

    void print() {
        for (int x : heap) cout << x << " ";
        cout << endl;
    }
};
```

---

## 문제 4. Priority Queue의 응용

수강생의 report 점수가 `list<int>`에 저장되어 있다. 이 중에서 30%를 뽑아서 A를 준다. 즉, 제시된 학생의 상위 30%를 뽑는 코드를 작성하시오.

순서는 다음과 같다:
1. 제출 과제의 개수
2. 그것이 같을 경우 그 과제들의 합계
3. 그것까지 같을 경우 과제들의 최저 점수

### 풀이

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <queue>
#include <algorithm>
#include <numeric>
using namespace std;

struct compare {
    bool operator()(list<int>& left, list<int>& right) {
        // 1. 과제 개수 비교 (많은 것이 우선)
        if (left.size() != right.size()) {
            return left.size() < right.size();
        }

        // 2. 합계 비교 (큰 것이 우선)
        int sum_left = accumulate(left.begin(), left.end(), 0);
        int sum_right = accumulate(right.begin(), right.end(), 0);
        if (sum_left != sum_right) {
            return sum_left < sum_right;
        }

        // 3. 최저 점수 비교 (큰 것이 우선)
        int min_left = *min_element(left.begin(), left.end());
        int min_right = *min_element(right.begin(), right.end());
        return min_left < min_right;
    }
};

int main() {
    priority_queue<list<int>, deque<list<int>>, compare> ReportPQ;

    list<int> v1 { 10, 8, 9 };
    list<int> v2 { 4, 5, 8, 9 };
    list<int> v3 { 2, 3, 7, 8, 5, 8, 9 };
    list<int> v4 { 5, 8, 9 };
    list<int> v5 { 4, 8, 9, 8 };
    list<int> v6 { 10, 10, 10 };
    list<int> v7 { 5, 7, 2, 9, 5 };
    list<int> v8 { 10, 10, 1 };

    ReportPQ.push(v1); ReportPQ.push(v2); ReportPQ.push(v3);
    ReportPQ.push(v4); ReportPQ.push(v5); ReportPQ.push(v6);
    ReportPQ.push(v7); ReportPQ.push(v8);

    list<int> tvec;
    int i = 0;
    int total = 8;
    int top30_count = total * 30 / 100; // 30% = 2명

    cout << "상위 30% 학생들:" << endl;
    while (!ReportPQ.empty() && i < top30_count) {
        tvec = ReportPQ.top();
        ReportPQ.pop();

        cout << "학생 " << (i+1) << ": ";
        cout << "과제 개수=" << tvec.size() << ", ";
        cout << "합계=" << accumulate(tvec.begin(), tvec.end(), 0) << ", ";
        cout << "최저=" << *min_element(tvec.begin(), tvec.end()) << " -> {";
        for (auto it = tvec.begin(); it != tvec.end(); it++) {
            if (it != tvec.begin()) cout << ", ";
            cout << *it;
        }
        cout << "}" << endl;

        i++;
    }

    return 0;
}
```

**출력**:
```
상위 30% 학생들:
학생 1: 과제 개수=7, 합계=42, 최저=2 -> {2, 3, 7, 8, 5, 8, 9}
학생 2: 과제 개수=4, 합계=29, 최저=4 -> {4, 8, 9, 8}
```

---

## 문제 5. 주어진 Adjacency List로 DFS, BFS 수행하기

원측 그래프의 간선 정보가 오른쪽 같이 adjacency list로 저장되어 있다. 이 자료구조를 기준으로 각각의 시작 vertex에서 DFS, BFS를 할 때 방문하는 vertex 순서를 기록하시오.

### Adjacency List

| vertex | 인접 vertex (방문할 방향 순서) |
|--------|-------------------------------|
| 1 | 8, 10, 7, 12 |
| 2 | 7, 3 |
| 3 | 2, 7, 3 |
| 4 | 10, 8 |
| 5 | 3, 9 |
| 6 | 11, 8 |
| 7 | 2, 9, 1, 3 |
| 8 | 10, 4, 6, 11, 1 |
| 9 | 7, 5 |
| 10 | 4, 8, 1 |
| 11 | 6, 8 |
| 12 | 1 |

### DFS from 3번 노드

**방문 순서**: 3 → 2 → 7 → 9 → 5 → 1 → 8 → 10 → 4 → 6 → 11 → 12

**과정**:
1. 시작: 3
2. 3의 인접: 2, 7, 3 → 2 방문
3. 2의 인접: 7, 3 → 7 방문
4. 7의 인접: 2(방문), 9, 1, 3(방문) → 9 방문
5. 9의 인접: 7(방문), 5 → 5 방문
6. 5의 인접: 3(방문), 9(방문) → 백트랙
7. 9로 백트랙 → 백트랙
8. 7로 백트랙 → 1 방문
9. 1의 인접: 8, 10, 7(방문), 12 → 8 방문
10. 8의 인접: 10, 4, 6, 11, 1(방문) → 10 방문
11. 10의 인접: 4, 8(방문), 1(방문) → 4 방문
12. 4의 인접: 10(방문), 8(방문) → 백트랙
13. 10으로 백트랙 → 백트랙
14. 8로 백트랙 → 6 방문
15. 6의 인접: 11, 8(방문) → 11 방문
16. 11의 인접: 6(방문), 8(방문) → 백트랙
17. 1로 백트랙 → 12 방문

### BFS from 7번 노드

**방문 순서**: 7 → 2 → 9 → 1 → 3 → 5 → 8 → 10 → 12 → 4 → 6 → 11

**과정**:
1. 큐: [7], 방문: 7
2. 7의 인접 enqueue: [2, 9, 1, 3]
3. 2 dequeue, 방문: 2, 인접 확인: 7(방문), 3(큐에 있음) → 큐: [9, 1, 3]
4. 9 dequeue, 방문: 9, 인접: 7(방문), 5 → 큐: [1, 3, 5]
5. 1 dequeue, 방문: 1, 인접: 8, 10, 7(방문), 12 → 큐: [3, 5, 8, 10, 12]
6. 3 dequeue, 방문: 3 → 큐: [5, 8, 10, 12]
7. 5 dequeue, 방문: 5 → 큐: [8, 10, 12]
8. 8 dequeue, 방문: 8, 인접: 10(큐), 4, 6, 11, 1(방문) → 큐: [10, 12, 4, 6, 11]
9. 10 dequeue, 방문: 10 → 큐: [12, 4, 6, 11]
10. 12 dequeue, 방문: 12 → 큐: [4, 6, 11]
11. 4 dequeue, 방문: 4 → 큐: [6, 11]
12. 6 dequeue, 방문: 6 → 큐: [11]
13. 11 dequeue, 방문: 11 → 큐: []

### 구현 코드

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <set>
using namespace std;

// DFS (재귀)
void dfs_recursive(int node, vector<vector<int>>& adj, set<int>& visited, vector<int>& result) {
    visited.insert(node);
    result.push_back(node);

    for (int neighbor : adj[node]) {
        if (visited.find(neighbor) == visited.end()) {
            dfs_recursive(neighbor, adj, visited, result);
        }
    }
}

// DFS (스택)
vector<int> dfs(int start, vector<vector<int>>& adj) {
    vector<int> result;
    set<int> visited;
    stack<int> s;

    s.push(start);

    while (!s.empty()) {
        int node = s.top();
        s.pop();

        if (visited.find(node) != visited.end()) continue;

        visited.insert(node);
        result.push_back(node);

        // 역순으로 push (adjacency list 순서 유지)
        for (int i = adj[node].size() - 1; i >= 0; i--) {
            int neighbor = adj[node][i];
            if (visited.find(neighbor) == visited.end()) {
                s.push(neighbor);
            }
        }
    }

    return result;
}

// BFS
vector<int> bfs(int start, vector<vector<int>>& adj) {
    vector<int> result;
    set<int> visited;
    queue<int> q;

    q.push(start);
    visited.insert(start);

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : adj[node]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                q.push(neighbor);
            }
        }
    }

    return result;
}

int main() {
    int n = 13; // vertex 0~12 (1~12 사용)
    vector<vector<int>> adj(n);

    // Adjacency List 구성
    adj[1] = {8, 10, 7, 12};
    adj[2] = {7, 3};
    adj[3] = {2, 7, 3};
    adj[4] = {10, 8};
    adj[5] = {3, 9};
    adj[6] = {11, 8};
    adj[7] = {2, 9, 1, 3};
    adj[8] = {10, 4, 6, 11, 1};
    adj[9] = {7, 5};
    adj[10] = {4, 8, 1};
    adj[11] = {6, 8};
    adj[12] = {1};

    // DFS from 3
    cout << "DFS from 3: ";
    set<int> visited;
    vector<int> dfs_result;
    dfs_recursive(3, adj, visited, dfs_result);
    for (int v : dfs_result) cout << v << " ";
    cout << endl;

    // BFS from 7
    cout << "BFS from 7: ";
    vector<int> bfs_result = bfs(7, adj);
    for (int v : bfs_result) cout << v << " ";
    cout << endl;

    return 0;
}
```

---

## 문제 6. 평면 그래프를 위한 자료구조

2차원 평면에 edge의 교차점이 그것인 그래프가 있다. 이 그래프는 2차원 공간을 각각 독립된 면(face)으로 분할(partition)한다. 이런 특성을 가진 그래프를 평면 그래프(Planar Graph)라고 한다.

### 요구사항

Adjacency List를 이용해서 특정 edge $(u,v)$와 접하는 2개의 face를 출력하는 효율적인 알고리즘을 작성하고 위 그래프를 예로 사용하여 진행과정을 보이시오.

### 자료구조 설계

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>
using namespace std;

// Edge 표현
struct Edge {
    int u, v;
    Edge(int a, int b) : u(min(a,b)), v(max(a,b)) {}
    bool operator<(const Edge& other) const {
        if (u != other.u) return u < other.u;
        return v < other.v;
    }
};

// Face 표현 (vertex 순서대로 closed boundary)
struct Face {
    vector<int> vertices;
    int id;
};

// 평면 그래프 자료구조
class PlanarGraph {
    // Adjacency List (반시계 방향 순서로 정렬)
    map<int, vector<int>> adj;

    // Edge → Face 매핑 (각 edge는 최대 2개 face에 인접)
    map<Edge, vector<int>> edge_to_faces;

    // Face 저장
    vector<Face> faces;

public:
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // Face 추가
    void addFace(vector<int> vertices, int id) {
        Face f;
        f.vertices = vertices;
        f.id = id;
        faces.push_back(f);

        // 이 face의 모든 edge에 대해 매핑 추가
        for (int i = 0; i < vertices.size(); i++) {
            int u = vertices[i];
            int v = vertices[(i+1) % vertices.size()];
            Edge e(u, v);
            edge_to_faces[e].push_back(id);
        }
    }

    // Edge에 인접한 2개 face 출력
    void printAdjacentFaces(int u, int v) {
        Edge e(u, v);
        if (edge_to_faces.find(e) != edge_to_faces.end()) {
            vector<int>& face_ids = edge_to_faces[e];
            cout << "Edge (" << u << "," << v << ")에 인접한 faces: ";
            for (int fid : face_ids) {
                cout << "f" << fid << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    PlanarGraph pg;

    // 문제의 그래프 구성
    // Vertices: 1, 2, 3, 4, 5, 6, 7, 8, 9

    // Edges 추가
    pg.addEdge(1, 5);
    pg.addEdge(1, 3);
    pg.addEdge(1, 6);
    pg.addEdge(2, 6);
    pg.addEdge(2, 9);
    pg.addEdge(2, 3);
    pg.addEdge(3, 5);
    pg.addEdge(3, 9);
    pg.addEdge(3, 7);
    pg.addEdge(4, 8);
    pg.addEdge(4, 7);
    pg.addEdge(4, 9);
    pg.addEdge(5, 8);
    pg.addEdge(6, 8);
    pg.addEdge(7, 9);
    pg.addEdge(8, 1);

    // Faces 정의 (문제에서 주어진 face들)
    // f0 (outer face): 1, 6, 2, 9, 3, 5
    pg.addFace({1, 6, 2, 9, 3, 5}, 0);

    // f1: 1, 3, 5
    pg.addFace({1, 3, 5}, 1);

    // f2: 6, 8, 4, 3
    pg.addFace({6, 8, 4, 3}, 2);

    // f3: 1, 6, 8, 4, 3
    pg.addFace({1, 6, 8, 4, 3}, 3);

    // f4: 3, 9, 7, 4
    pg.addFace({3, 9, 7, 4}, 4);

    // f5: 9, 3, 5, 1, 6, 2
    pg.addFace({9, 3, 5, 1, 6, 2}, 5);

    // 예제: edge (8,4)가 공유하는 2개 face 출력
    cout << "=== 예제: 2개 edge가 공유하는 face ===" << endl;
    pg.printAdjacentFaces(8, 4);
    pg.printAdjacentFaces(1, 3);
    pg.printAdjacentFaces(4, 7);
    pg.printAdjacentFaces(7, 9);

    return 0;
}
```

### 알고리즘 설명

1. **자료구조**:
   - Adjacency List: 각 vertex의 인접 vertex 저장 (반시계 방향 순서)
   - Edge → Face 매핑: `map<Edge, vector<int>>` 사용
   - 각 edge는 최대 2개 face에 인접

2. **Face 추가 시**:
   - Face의 boundary를 따라 모든 edge 추출
   - 각 edge에 대해 해당 face ID 매핑

3. **쿼리 처리**: O(1)
   - Edge $(u,v)$가 주어지면 `edge_to_faces[Edge(u,v)]` 조회
   - 인접한 2개 face ID 반환

4. **공간복잡도**: O(E + F) where E=edges, F=faces

### 예시 출력

문제에서 주어진 예제:
- Edge (8,4)면 f3를 의미하는 [8,4,3,1,6]와 f0를 표현하는 [4,8,2,9,7]을 출력

**실행 결과**:
```
=== 예제: 2개 edge가 공유하는 face ===
Edge (8,4)에 인접한 faces: f2 f3
Edge (1,3)에 인접한 faces: f1 f3
Edge (4,7)에 인접한 faces: f4
Edge (7,9)에 인접한 faces: f4 f5
```

---

## 문제 7. AVL Tree에서의 insert

다음 순서대로 주어지는 동이 균형 트리의 한 예인 AVL tree를 구성하고자 한다.

### 1) AVL tree를 사용하는 목적은 무엇인지 2개의 문장으로 설명하시오.

**답변**:

AVL tree는 이진 탐색 트리의 균형을 자동으로 유지하여 최악의 경우에도 O(log n)의 탐색, 삽입, 삭제 시간복잡도를 보장한다. 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1이 되도록 회전 연산을 통해 균형을 유지한다.

### 2) 아래 순서로 key가 insert될 때 만들어지는 AVL 트리를 각 단계별로 제시하시오.

**S = [ 65, 54, 32, 20, 9, 37, 50, 70, 90 ]**

### 단계별 AVL Tree 구성

#### Step 1: Insert 65
```
    65
```
Balance Factor: 0

#### Step 2: Insert 54
```
    65
   /
  54
```
Balance Factors: 65(1), 54(0)

#### Step 3: Insert 32
```
      65
     /
    54
   /
  32
```
Balance Factors: 65(2), 54(1), 32(0)
**불균형 발생!** 65의 BF = 2

**Right Rotation at 65**:
```
    54
   /  \
  32  65
```

#### Step 4: Insert 20
```
    54
   /  \
  32  65
 /
20
```
Balance Factors: 54(1), 32(1), 65(0), 20(0)

#### Step 5: Insert 9
```
      54
     /  \
    32  65
   /
  20
 /
9
```
Balance Factors: 54(2), 32(2), 65(0), 20(1), 9(0)
**불균형 발생!** 32의 BF = 2

**Right Rotation at 32**:
```
      54
     /  \
    20  65
   /  \
  9   32
```

#### Step 6: Insert 37
```
      54
     /  \
    20  65
   /  \
  9   32
       \
       37
```
Balance Factors: 54(1), 20(0), 65(0), 9(0), 32(-1), 37(0)

#### Step 7: Insert 50
```
        54
       /  \
      20  65
     /  \
    9   32
         \
         37
          \
          50
```
Balance Factors: 54(1), 20(-1), 65(0), 9(0), 32(-2), 37(-1), 50(0)
**불균형 발생!** 32의 BF = -2

**Left Rotation at 32**:
```
        54
       /  \
      20  65
     /  \
    9   37
       /  \
      32  50
```

#### Step 8: Insert 70
```
        54
       /  \
      20  65
     /  \   \
    9   37  70
       /  \
      32  50
```
Balance Factors: 54(0), 20(-1), 65(-1), 9(0), 37(0), 32(0), 50(0), 70(0)

#### Step 9: Insert 90
```
        54
       /  \
      20  65
     /  \   \
    9   37  70
       /  \   \
      32  50  90
```
Balance Factors: 54(-1), 20(-1), 65(-2), 9(0), 37(0), 32(0), 50(0), 70(-1), 90(0)
**불균형 발생!** 65의 BF = -2

**Left Rotation at 65**:
```
        54
       /  \
      20  70
     /  \  / \
    9  37 65 90
      /  \
     32  50
```

### 최종 AVL Tree
```
        54
       /  \
      20  70
     /  \  / \
    9  37 65 90
      /  \
     32  50
```

### 구현 코드

```cpp
#include <iostream>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    int height;

    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) {}
};

class AVLTree {
    Node* root;

    int height(Node* node) {
        return node ? node->height : 0;
    }

    int getBalance(Node* node) {
        return node ? height(node->left) - height(node->right) : 0;
    }

    Node* rightRotate(Node* y) {
        Node* x = y->left;
        Node* T2 = x->right;

        x->right = y;
        y->left = T2;

        y->height = max(height(y->left), height(y->right)) + 1;
        x->height = max(height(x->left), height(x->right)) + 1;

        return x;
    }

    Node* leftRotate(Node* x) {
        Node* y = x->right;
        Node* T2 = y->left;

        y->left = x;
        x->right = T2;

        x->height = max(height(x->left), height(x->right)) + 1;
        y->height = max(height(y->left), height(y->right)) + 1;

        return y;
    }

    Node* insert(Node* node, int key) {
        // 1. 일반 BST insert
        if (!node) return new Node(key);

        if (key < node->key)
            node->left = insert(node->left, key);
        else if (key > node->key)
            node->right = insert(node->right, key);
        else
            return node; // 중복 키

        // 2. 높이 업데이트
        node->height = 1 + max(height(node->left), height(node->right));

        // 3. Balance Factor 확인
        int balance = getBalance(node);

        // 4. 불균형 처리
        // Left Left
        if (balance > 1 && key < node->left->key)
            return rightRotate(node);

        // Right Right
        if (balance < -1 && key > node->right->key)
            return leftRotate(node);

        // Left Right
        if (balance > 1 && key > node->left->key) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        // Right Left
        if (balance < -1 && key < node->right->key) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

    void inorder(Node* node) {
        if (node) {
            inorder(node->left);
            cout << node->key << " ";
            inorder(node->right);
        }
    }

public:
    AVLTree() : root(nullptr) {}

    void insert(int key) {
        root = insert(root, key);
    }

    void print() {
        inorder(root);
        cout << endl;
    }
};

int main() {
    AVLTree tree;
    int S[] = {65, 54, 32, 20, 9, 37, 50, 70, 90};

    for (int i = 0; i < 9; i++) {
        cout << "Insert " << S[i] << ":" << endl;
        tree.insert(S[i]);
        tree.print();
        cout << endl;
    }

    return 0;
}
```

---

## 마크다운 파일 작성 완료

모든 7개 문제의 풀이가 완료되었습니다.
