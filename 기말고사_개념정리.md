# ğŸ“š ìë£Œêµ¬ì¡° ê¸°ë§ê³ ì‚¬ ëŒ€ë¹„ ê°œë… ì •ë¦¬

> **ê¸°ë§ê³ ì‚¬ ë²”ìœ„**: 16ë²ˆ ~ 25ë²ˆ ë¬¸ì œ (20, 23ë²ˆ ì œì™¸)
> **ì‘ì„±ì¼**: 2025-12-15
> **ì´ ë¬¸ì œ ìˆ˜**: 8ê°œ

---

## ğŸ“‹ ëª©ì°¨

1. [ë¬¸ì œ ê°œìš”](#ë¬¸ì œ-ê°œìš”)
2. [Tree (íŠ¸ë¦¬)](#1-tree-íŠ¸ë¦¬)
3. [Binary Search Tree (BST)](#2-binary-search-tree-bst)
4. [Quad Tree](#3-quad-tree-ì¬ê·€-êµ¬ì¡°)
5. [Graph - BFS/Dijkstra](#4-graph---bfsdijkstra)
6. [Hash & Map](#5-hash--map)
7. [Stack](#6-stack)
8. [ì •ë ¬ ê¸°ì¤€ (Comparator)](#7-ì •ë ¬-ê¸°ì¤€-comparator)
9. [í•µì‹¬ ì²´í¬ë¦¬ìŠ¤íŠ¸](#í•µì‹¬-ì²´í¬ë¦¬ìŠ¤íŠ¸)
10. [ë¬¸ì œë³„ í•µì‹¬ ì•Œê³ ë¦¬ì¦˜](#ë¬¸ì œë³„-í•µì‹¬-ì•Œê³ ë¦¬ì¦˜)

---

## ë¬¸ì œ ê°œìš”

### 16. Complexity (ë³µì¡ë„)
- **ìë£Œêµ¬ì¡°**: Tree
- **í•µì‹¬**: C/C++ ì†ŒìŠ¤ì½”ë“œì—ì„œ `{}`ë§Œ ì¶”ì¶œí•´ BLOCK íŠ¸ë¦¬ êµ¬ì„±, ëª¨ë“  ë…¸ë“œì˜ depth í•© ê³„ì‚°
- **ì…ë ¥**: ì†ŒìŠ¤ì½”ë“œ (ìµœëŒ€ 1000ì¤„)
- **ì¶œë ¥**: ë³µì¡ë„ (ì •ìˆ˜)
- **ì œí•œ**: Token ì œí•œ ì—†ìŒ, 1ì´ˆ
- **ë‚œì´ë„**: â­â­

### 17. Mafia (ë§ˆí”¼ì•„)
- **ìë£Œêµ¬ì¡°**: Tree
- **í•µì‹¬**: ë§ˆí”¼ì•„ ì¡°ì§ì˜ ì„œì—´ ê²°ì •
  1. ë¶€í•˜ ìˆ˜ê°€ ë§ì„ìˆ˜ë¡ ë†’ì€ ìˆœìœ„
  2. ë¶€í•˜ ìˆ˜ ê°™ìœ¼ë©´ rootì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ìŒ
  3. ë‘˜ ë‹¤ ê°™ìœ¼ë©´ ì´ë¦„ ì‚¬ì „ìˆœ
- **ì…ë ¥**: N(5â‰¤Nâ‰¤500), N-1ê°œì˜ ìƒí•˜ê´€ê³„
- **ì¶œë ¥**: ì„œì—´ ìˆœì„œëŒ€ë¡œ Nê°œ ì´ë¦„
- **ì œí•œ**: Tokenâ‰¤650, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­

### 18. Quad Tree (ì¿¼ë“œ íŠ¸ë¦¬)
- **ìë£Œêµ¬ì¡°**: Quad Tree
- **í•µì‹¬**: 2^kÃ—2^k ì´ë¯¸ì§€ â†” QTS ë¬¸ìì—´ ìƒí˜¸ ë³€í™˜
  - IMG â†’ QTS: ì¬ê·€ì ìœ¼ë¡œ 4ë¶„í• , ëª¨ë‘ ê°™ìœ¼ë©´ 0/1, ì„ì—¬ìˆìœ¼ë©´ (QT1 QT2 QT3 QT4)
  - QTS â†’ IMG: ì¬ê·€ íŒŒì‹±í•˜ì—¬ ì´ë¯¸ì§€ ë³µì›
- **ì…ë ¥**: k(2â‰¤kâ‰¤7), IMG/QTS
- **ì¶œë ¥**: QTS/IMG
- **ì œí•œ**: Tokenâ‰¤700, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­â­

### 19. BTS Machine
- **ìë£Œêµ¬ì¡°**: Binary Search Tree
- **í•µì‹¬**: ë™ì  BST êµ¬í˜„ (ì‚½ì…, ì‚­ì œ, depth k ì¶œë ¥, leaf ì¶œë ¥)
  - ì‚­ì œ: ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ ìµœëŒ€ê°’ ë˜ëŠ” ì˜¤ë¥¸ìª½ ìµœì†Œê°’ìœ¼ë¡œ ëŒ€ì²´
- **ì…ë ¥**: ëª…ë ¹ì–´ (2~100ê°œ): `+ string`, `- string`, `depth k`, `leaf`, `quit`
- **ì¶œë ¥**: depth k, leaf ê²°ê³¼ (ì‚¬ì „ìˆœ)
- **ì œí•œ**: Tokenâ‰¤700, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­â­
- **íŠ¹ì´ì‚¬í•­**: ê¸°ë§ê³ ì‚¬ ë¬¸ì œë¡œ í™œìš©, ë§Œì ì ì¤‘ ìš°ì•„í•œ ì½”ë“œ 3ëª… ë³´ë„ˆìŠ¤ 5ì 

### 21. Party (ì¢…ê°• íŒŒí‹°)
- **ìë£Œêµ¬ì¡°**: Graph (BFS/Dijkstra)
- **í•µì‹¬**: 3ëª…ì´ ê°€ì¥ ë¹¨ë¦¬ ë§Œë‚  ìˆ˜ ìˆëŠ” ì •ì  ì°¾ê¸°
  - Edge ì´ë™: 1ë¶„, Vertex í†µê³¼: 2ë¶„
  - 3ëª… ëª¨ë‘ ë„ì°© ì‹œê°„ì˜ ìµœëŒ€ê°’ì´ ìµœì†Œì¸ ì •ì 
  - Disconnected ê·¸ë˜í”„ë©´ `@`, `-1` ì¶œë ¥
- **ì…ë ¥**: N(3â‰¤Nâ‰¤26), 3ëª… ìœ„ì¹˜, ì¸ì ‘ ë¦¬ìŠ¤íŠ¸
- **ì¶œë ¥**: ìµœì  ì •ì , ì‹œê°„
- **ì œí•œ**: Tokenâ‰¤650, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­â­

### 22. Delivery Robot (ë°°ë‹¬ ë¡œë´‡)
- **ìë£Œêµ¬ì¡°**: Graph (BFS with state)
- **í•µì‹¬**: NÃ—N ê·¸ë¦¬ë“œì—ì„œ (1,1)â†’(N,N) ìµœë‹¨ì‹œê°„
  - ì´ë™: 1ë¶„/ì¹¸
  - ë°©í–¥ ì „í™˜(turn): të¶„ (2â‰¤tâ‰¤5)
  - State: (x, y, direction)
- **ì…ë ¥**: N(3â‰¤Nâ‰¤25), t, ê·¸ë¦¬ë“œ (0/1)
- **ì¶œë ¥**: ìµœë‹¨ì‹œê°„ (ë„ë‹¬ ë¶ˆê°€ë©´ -1)
- **ì œí•œ**: Tokenâ‰¤700, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­â­â­

### 24. GDBC (ìœ ì „ì§ˆí™˜ ì„¼í„°)
- **ìë£Œêµ¬ì¡°**: Map/Hash (setì„ keyë¡œ ì‚¬ìš©)
- **í•µì‹¬**: ìœ ì „ì ì§‘í•© â†’ ì§ˆë³‘ ë§¤í•‘
  - `R gene1 gene2 ... -disease`: ë“±ë¡
  - `Q gene1 gene2 ... 0`: ì§ˆì˜ (ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ìœ ì „ì ì§‘í•©)
  - ê²°ê³¼ë¥¼ ë‚´ë¦¼ì°¨ìˆœ ì¶œë ¥, ì—†ìœ¼ë©´ "None"
- **ì…ë ¥**: ìµœëŒ€ 100,000ì¤„
- **ì¶œë ¥**: Queryë§ˆë‹¤ ì§ˆë³‘ ì½”ë“œë“¤ (ë‚´ë¦¼ì°¨ìˆœ)
- **ì œí•œ**: Tokenâ‰¤500, 1ì´ˆ, **ë°˜ë“œì‹œ STL map ë˜ëŠ” dict ì‚¬ìš©**
- **ë‚œì´ë„**: â­â­â­â­

### 25. Giftcode (ë¬¸í™” ìƒí’ˆê¶Œ)
- **ìë£Œêµ¬ì¡°**: Hash, Set
- **í•µì‹¬**: 20ìë¦¬ ìƒí’ˆê¶Œ ê²€ì¦
  - K(12ìë¦¬) â†’ PNUhash(K, salt) â†’ H(8ìë¦¬)
  - ì˜¬ë°”ë¥¸ ë°°ì¹˜ì¸ì§€ í™•ì¸, ì¤‘ë³µ ì‚¬ìš© ì²´í¬
  - Valid / Invalid / Used ê°œìˆ˜ ì„¸ê¸°
- **ì…ë ¥**: N(100â‰¤Nâ‰¤500,000), salt, Nê°œ ì½”ë“œ
- **ì¶œë ¥**: valid ê°œìˆ˜, invalid ê°œìˆ˜, used ê°œìˆ˜
- **ì œí•œ**: Tokenâ‰¤700, 1ì´ˆ
- **ë‚œì´ë„**: â­â­â­

---

## 1. Tree (íŠ¸ë¦¬)

### 1.1 ê¸°ë³¸ ê°œë…

- **Root**: íŠ¸ë¦¬ì˜ ìµœìƒìœ„ ë…¸ë“œ
- **Parent**: ë¶€ëª¨ ë…¸ë“œ
- **Child**: ìì‹ ë…¸ë“œ
- **Leaf**: ìì‹ì´ ì—†ëŠ” ë…¸ë“œ
- **Depth**: ë£¨íŠ¸ë¡œë¶€í„°ì˜ ê±°ë¦¬ (ë£¨íŠ¸ì˜ depth = 0 or 1, ë¬¸ì œì— ë”°ë¼ ë‹¤ë¦„)
- **Height**: ë¦¬í”„ê¹Œì§€ì˜ ìµœëŒ€ ê±°ë¦¬
- **Rooted Tree**: ë£¨íŠ¸ê°€ ì •í•´ì§„ íŠ¸ë¦¬
- **Ordered Tree**: ìì‹ ë…¸ë“œì˜ ìˆœì„œê°€ ì¤‘ìš”í•œ íŠ¸ë¦¬
- **Degree**: ë…¸ë“œì˜ ìì‹ ê°œìˆ˜

### 1.2 íŠ¸ë¦¬ ìˆœíšŒ (DFS)

```cpp
// ì¬ê·€ì  DFS
void dfs(Node* node, int depth) {
    if (!node) return;

    // ì „ìœ„ ìˆœíšŒ ì²˜ë¦¬ (Pre-order)
    cout << node->data << " ";

    for (auto child : node->children) {
        dfs(child, depth + 1);
    }

    // í›„ìœ„ ìˆœíšŒ ì²˜ë¦¬ (Post-order)
}
```

### 1.3 ë¶€í•˜ ìˆ˜ ê³„ì‚° (17ë²ˆ Mafia)

```cpp
int countSubordinates(Node* node) {
    int count = 0;
    for (auto child : node->children) {
        count += 1 + countSubordinates(child);
    }
    return count;
}
```

### 1.4 íŠ¸ë¦¬ ìë£Œêµ¬ì¡° í‘œí˜„

```cpp
// ë°©ë²• 1: í´ë˜ìŠ¤ ê¸°ë°˜
struct Node {
    string name;
    vector<Node*> children;
};

// ë°©ë²• 2: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (ë” íš¨ìœ¨ì )
vector<vector<string>> children(N);
// children[i] = ië²ˆ ë…¸ë“œì˜ ìì‹ë“¤

// ë°©ë²• 3: map ì‚¬ìš© (ë¬¸ìì—´ í‚¤)
map<string, vector<string>> children;
```

---

## 2. Binary Search Tree (BST)

### 2.1 í•µì‹¬ ì„±ì§ˆ

- ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ëª¨ë“  ê°’ < í˜„ì¬ ë…¸ë“œ < ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ëª¨ë“  ê°’
- ì¤‘ìœ„ ìˆœíšŒ(In-order)í•˜ë©´ ì •ë ¬ëœ ìˆœì„œë¡œ ì¶œë ¥ë¨

### 2.2 ì‚½ì… (Insert)

```cpp
Node* insert(Node* root, string key) {
    if (!root) return new Node(key);

    if (key < root->key)
        root->left = insert(root->left, key);
    else if (key > root->key)
        root->right = insert(root->right, key);
    // key == root->keyì´ë©´ ì¤‘ë³µ, ë¬´ì‹œ

    return root;
}
```

### 2.3 ì‚­ì œ (Delete) - 19ë²ˆ BTS í•µì‹¬! â­â­â­

```cpp
Node* deleteNode(Node* root, string key) {
    if (!root) return nullptr;

    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    }
    else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    }
    else {
        // ì°¾ì•˜ë‹¤!

        // Case 1: Leaf ë…¸ë“œ
        if (!root->left && !root->right) {
            delete root;
            return nullptr;
        }

        // Case 2: ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ìˆìŒ â†’ ì™¼ìª½ ìµœëŒ€ê°’ìœ¼ë¡œ êµì²´
        if (root->left) {
            Node* maxNode = findMax(root->left);
            root->key = maxNode->key;
            root->left = deleteNode(root->left, maxNode->key);
        }
        // Case 3: ì˜¤ë¥¸ìª½ë§Œ ìˆìŒ â†’ ì˜¤ë¥¸ìª½ ìµœì†Œê°’ìœ¼ë¡œ êµì²´
        else {
            Node* minNode = findMin(root->right);
            root->key = minNode->key;
            root->right = deleteNode(root->right, minNode->key);
        }
    }
    return root;
}

Node* findMax(Node* node) {
    while (node->right) node = node->right;
    return node;
}

Node* findMin(Node* node) {
    while (node->left) node = node->left;
    return node;
}
```

### 2.4 íŠ¹ì • Depth ë…¸ë“œ ì°¾ê¸°

```cpp
void findAtDepth(Node* node, int currentDepth, int targetDepth,
                 vector<string>& result) {
    if (!node) return;

    if (currentDepth == targetDepth) {
        result.push_back(node->key);
        return;
    }

    findAtDepth(node->left, currentDepth + 1, targetDepth, result);
    findAtDepth(node->right, currentDepth + 1, targetDepth, result);
}
```

### 2.5 Leaf ë…¸ë“œ ì°¾ê¸°

```cpp
void findLeaves(Node* node, vector<string>& result) {
    if (!node) return;

    if (!node->left && !node->right) {
        result.push_back(node->key);
        return;
    }

    findLeaves(node->left, result);
    findLeaves(node->right, result);
}
```

---

## 3. Quad Tree (ì¬ê·€ êµ¬ì¡°)

### 3.1 ê°œë…

- 2D ê³µê°„ì„ 4ê°œì˜ ì‚¬ë¶„ë©´ìœ¼ë¡œ ì¬ê·€ì ìœ¼ë¡œ ë¶„í• 
- ì´ë¯¸ì§€ ì••ì¶•ì— ì‚¬ìš©
- ê° ë…¸ë“œëŠ” 0ê°œ(ë¦¬í”„) ë˜ëŠ” 4ê°œ(ë‚´ë¶€ ë…¸ë“œ)ì˜ ìì‹ì„ ê°€ì§

### 3.2 IMG â†’ QTS ì¸ì½”ë”©

```cpp
string encode(vector<vector<int>>& img, int x, int y, int size) {
    // Base case: ëª¨ë‘ ê°™ì€ ê°’ì¸ì§€ í™•ì¸
    bool allSame = true;
    int first = img[y][x];

    for (int i = 0; i < size && allSame; i++) {
        for (int j = 0; j < size && allSame; j++) {
            if (img[y+i][x+j] != first)
                allSame = false;
        }
    }

    if (allSame) return to_string(first);

    // 4ë¶„í• 
    int half = size / 2;
    string q1 = encode(img, x,        y,        half); // ì™¼ìª½ ìœ„ (1ì‚¬ë¶„ë©´)
    string q2 = encode(img, x + half, y,        half); // ì˜¤ë¥¸ìª½ ìœ„ (2ì‚¬ë¶„ë©´)
    string q3 = encode(img, x,        y + half, half); // ì™¼ìª½ ì•„ë˜ (3ì‚¬ë¶„ë©´)
    string q4 = encode(img, x + half, y + half, half); // ì˜¤ë¥¸ìª½ ì•„ë˜ (4ì‚¬ë¶„ë©´)

    return "(" + q1 + q2 + q3 + q4 + ")";
}
```

### 3.3 QTS â†’ IMG ë””ì½”ë”©

```cpp
int idx = 0; // ì „ì—­ ë³€ìˆ˜

void decode(string qts, vector<vector<int>>& img, int x, int y, int size) {
    char c = qts[idx++];

    if (c == '0' || c == '1') {
        // ì˜ì—­ ì „ì²´ë¥¼ cë¡œ ì±„ì›€
        int val = c - '0';
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                img[y+i][x+j] = val;
            }
        }
        return;
    }

    // c == '('
    int half = size / 2;
    decode(qts, img, x,        y,        half); // q1
    decode(qts, img, x + half, y,        half); // q2
    decode(qts, img, x,        y + half, half); // q3
    decode(qts, img, x + half, y + half, half); // q4
    idx++; // ')' ê±´ë„ˆë›°ê¸°
}

// ì‚¬ìš© ì˜ˆì‹œ
int main() {
    string qts;
    cin >> qts;
    idx = 0;
    vector<vector<int>> img(size, vector<int>(size));
    decode(qts, img, 0, 0, size);
}
```

---

## 4. Graph - BFS/Dijkstra

### 4.1 BFS ê¸°ë³¸ (21ë²ˆ Party)

```cpp
#include <queue>
#include <vector>
using namespace std;

vector<int> bfs(int start, vector<vector<int>>& graph, int n) {
    vector<int> dist(n, -1);
    queue<int> q;

    q.push(start);
    dist[start] = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : graph[u]) {
            if (dist[v] == -1) {
                // edge 1ë¶„ + vertex 2ë¶„ = 3ë¶„
                dist[v] = dist[u] + 3;
                q.push(v);
            }
        }
    }

    return dist;
}
```

### 4.2 ì—°ê²° ì„±ë¶„ í™•ì¸

```cpp
bool isConnected(vector<vector<int>>& graph, int n, vector<int>& starts) {
    vector<bool> visited(n, false);
    queue<int> q;

    q.push(starts[0]);
    visited[starts[0]] = true;
    int count = 1;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                count++;
                q.push(v);
            }
        }
    }

    // 3ëª…ì˜ ì‹œì‘ì ì´ ëª¨ë‘ ê°™ì€ ì»´í¬ë„ŒíŠ¸ì— ìˆëŠ”ì§€ í™•ì¸
    for (int s : starts) {
        if (!visited[s]) return false;
    }

    return true;
}
```

### 4.3 ìƒíƒœ ê³µê°„ BFS (22ë²ˆ Delivery Robot - í•µì‹¬!) â­â­â­â­â­

```cpp
struct State {
    int x, y, dir, time;
};

// ë°©í–¥: 0=ìƒ, 1=ìš°, 2=í•˜, 3=ì¢Œ
int dx[] = {0, 1, 0, -1};
int dy[] = {-1, 0, 1, 0};

int bfs(vector<vector<int>>& grid, int n, int turnCost) {
    // dist[x][y][dir] = (x, y)ì— dir ë°©í–¥ìœ¼ë¡œ ë„ì°©í•œ ìµœì†Œ ì‹œê°„
    int dist[n][n][4];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int k = 0; k < 4; k++)
                dist[i][j][k] = -1;

    queue<State> q;

    // ì‹œì‘ì  (0, 0)ì—ì„œ 4ë°©í–¥ ëª¨ë‘ ê°€ëŠ¥
    for (int d = 0; d < 4; d++) {
        q.push({0, 0, d, 0});
        dist[0][0][d] = 0;
    }

    while (!q.empty()) {
        State cur = q.front();
        q.pop();

        // í˜„ì¬ ì‹œê°„ì´ ê¸°ë¡ëœ ìµœì†Œ ì‹œê°„ë³´ë‹¤ í¬ë©´ ìŠ¤í‚µ
        if (dist[cur.x][cur.y][cur.dir] < cur.time) continue;

        // 1. ì§ì§„
        int nx = cur.x + dx[cur.dir];
        int ny = cur.y + dy[cur.dir];

        if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[ny][nx] == 0) {
            int newTime = cur.time + 1;
            if (dist[nx][ny][cur.dir] == -1 || dist[nx][ny][cur.dir] > newTime) {
                dist[nx][ny][cur.dir] = newTime;
                q.push({nx, ny, cur.dir, newTime});
            }
        }

        // 2. ë°©í–¥ ì „í™˜ (ì œìë¦¬ì—ì„œ)
        for (int newDir = 0; newDir < 4; newDir++) {
            if (newDir == cur.dir) continue;

            int newTime = cur.time + turnCost;
            if (dist[cur.x][cur.y][newDir] == -1 ||
                dist[cur.x][cur.y][newDir] > newTime) {
                dist[cur.x][cur.y][newDir] = newTime;
                q.push({cur.x, cur.y, newDir, newTime});
            }
        }
    }

    // ëª©ì ì§€ (n-1, n-1)ì—ì„œ 4ë°©í–¥ ì¤‘ ìµœì†Œê°’ ì°¾ê¸°
    int result = INT_MAX;
    for (int d = 0; d < 4; d++) {
        if (dist[n-1][n-1][d] != -1) {
            result = min(result, dist[n-1][n-1][d]);
        }
    }

    return result == INT_MAX ? -1 : result;
}
```

### 4.4 í•µì‹¬ ì°¨ì´ì 

| ê¸°ë³¸ BFS | ìƒíƒœ ê³µê°„ BFS |
|---------|--------------|
| `dist[v]` | `dist[x][y][dir]` |
| ì •ì ë§Œ ì¶”ì  | ì •ì  + ìƒíƒœ ì¶”ì  |
| ê°„ë‹¨í•œ ìµœë‹¨ê²½ë¡œ | ë³µì¡í•œ ì¡°ê±´ì˜ ìµœë‹¨ê²½ë¡œ |

---

## 5. Hash & Map

### 5.1 STL map ê¸°ë³¸ (24ë²ˆ GDBC)

```cpp
#include <map>
#include <set>
#include <vector>
#include <algorithm>

// setì„ keyë¡œ ì‚¬ìš©í•˜ëŠ” map
map<set<int>, vector<int>> database;

// ë“±ë¡
void registerDisease(vector<int> genes, int disease) {
    set<int> geneSet(genes.begin(), genes.end());
    database[geneSet].push_back(disease);
}

// ì§ˆì˜
void query(vector<int> genes) {
    set<int> geneSet(genes.begin(), genes.end());

    if (database.find(geneSet) != database.end()) {
        vector<int> diseases = database[geneSet];
        sort(diseases.rbegin(), diseases.rend()); // ë‚´ë¦¼ì°¨ìˆœ

        for (int i = 0; i < diseases.size(); i++) {
            cout << diseases[i];
            if (i < diseases.size() - 1) cout << " ";
        }
        cout << "\n";
    } else {
        cout << "None\n";
    }
}
```

### 5.2 Python dict (24ë²ˆ)

```python
from collections import defaultdict

# frozensetì„ keyë¡œ ì‚¬ìš© (setì€ unhashable)
database = defaultdict(list)

# ë“±ë¡
def register_disease(genes, disease):
    gene_set = frozenset(genes)
    database[gene_set].append(disease)

# ì§ˆì˜
def query(genes):
    gene_set = frozenset(genes)

    if gene_set in database:
        diseases = sorted(database[gene_set], reverse=True)
        print(' '.join(map(str, diseases)))
    else:
        print("None")
```

### 5.3 Hash í•¨ìˆ˜ ì‚¬ìš© (25ë²ˆ Giftcode)

```cpp
#define HM 100000000

unsigned long PNUhash(unsigned long long x, int salt) {
    x = x + salt;
    x = (x ^ (x >> 30)) * UINT64_C(0xbf58476d1ce4e5b9);
    x = (x ^ (x >> 27)) * UINT64_C(0x94d049bb133111eb);
    x = x ^ (x >> 31);
    return x % HM;
}
```

### 5.4 ì½”ë“œ ê²€ì¦ ë° ì¤‘ë³µ ì²´í¬

```cpp
#include <unordered_set>
#include <string>

bool isValidCode(string code, int salt) {
    // code: 20ìë¦¬ ë¬¸ìì—´ "35345656792389299026"
    // K ì¶”ì¶œ (3,4,5,6ìë¦¬, 7,8,9,10ìë¦¬, 12,13,14,15ìë¦¬, 17,18,19,20ìë¦¬)

    string k_str = "";
    k_str += code.substr(2, 4);  // d1 d2 d3 d4
    k_str += code.substr(7, 4);  // d5 d6 d7 d8
    k_str += code.substr(12, 4); // d9 d10 d11 d12

    unsigned long long K = stoull(k_str);

    // í•´ì‹œ ê³„ì‚°
    unsigned long H = PNUhash(K, salt);

    // Hë¥¼ 8ìë¦¬ ë¬¸ìì—´ë¡œ ë³€í™˜ (leading zero í¬í•¨)
    string h_str = to_string(H);
    while (h_str.length() < 8) h_str = "0" + h_str;

    // ê²€ì¦: H1 H2 ... H8ì´ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€
    return code[0] == h_str[0] && code[1] == h_str[1] &&
           code[5] == h_str[2] && code[6] == h_str[3] &&
           code[10] == h_str[4] && code[11] == h_str[5] &&
           code[15] == h_str[6] && code[16] == h_str[7];
}

// ì¤‘ë³µ ì²´í¬
unordered_set<string> usedCodes;

int main() {
    int n, salt;
    cin >> n >> salt;

    int valid = 0, invalid = 0, used = 0;

    for (int i = 0; i < n; i++) {
        string code;
        cin >> code;

        if (!isValidCode(code, salt)) {
            invalid++;
        } else if (usedCodes.find(code) != usedCodes.end()) {
            used++;
        } else {
            valid++;
            usedCodes.insert(code);
        }
    }

    cout << valid << "\n" << invalid << "\n" << used << "\n";
}
```

---

## 6. Stack

### 6.1 ê´„í˜¸ ë§¤ì¹­ (16ë²ˆ Complexity)

```cpp
#include <stack>
#include <string>

int calculateComplexity(string code) {
    stack<int> st; // depth ì €ì¥
    int totalComplexity = 0;
    int depth = 0;

    for (char c : code) {
        if (c == '{') {
            depth++;
            totalComplexity += depth;
        } else if (c == '}') {
            depth--;
        }
    }

    return totalComplexity;
}

// ë˜ëŠ” íŠ¸ë¦¬ë¡œ êµ¬ì„±
struct Node {
    vector<Node*> children;
    int depth;
};

int dfsComplexity(Node* node, int depth) {
    int total = depth;
    for (auto child : node->children) {
        total += dfsComplexity(child, depth + 1);
    }
    return total;
}
```

### 6.2 ì½”ë“œì—ì„œ ì¤‘ê´„í˜¸ë§Œ ì¶”ì¶œ

```cpp
string extractBraces(string code) {
    string result = "";

    for (char c : code) {
        if (c == '{' || c == '}') {
            result += c;
        }
    }

    return result;
}
```

---

## 7. ì •ë ¬ ê¸°ì¤€ (Comparator)

### 7.1 ë‹¤ë‹¨ê³„ ì •ë ¬ (17ë²ˆ Mafia)

```cpp
#include <algorithm>
#include <vector>
#include <string>

struct Person {
    string name;
    int subordinates;  // ë¶€í•˜ ìˆ˜
    int depth;         // rootë¡œë¶€í„°ì˜ ê±°ë¦¬
};

bool compare(const Person& a, const Person& b) {
    // 1ìˆœìœ„: ë¶€í•˜ ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ (ë§ì€ ìˆœ)
    if (a.subordinates != b.subordinates)
        return a.subordinates > b.subordinates;

    // 2ìˆœìœ„: depth ì˜¤ë¦„ì°¨ìˆœ (rootì— ê°€ê¹Œìš´ ìˆœ)
    if (a.depth != b.depth)
        return a.depth < b.depth;

    // 3ìˆœìœ„: ì´ë¦„ ì‚¬ì „ìˆœ
    return a.name < b.name;
}

int main() {
    vector<Person> people;
    // ... ë°ì´í„° ì…ë ¥

    sort(people.begin(), people.end(), compare);

    for (const auto& p : people) {
        cout << p.name << "\n";
    }
}
```

### 7.2 STL ì •ë ¬ í•¨ìˆ˜ë“¤

```cpp
// ì˜¤ë¦„ì°¨ìˆœ
sort(v.begin(), v.end());

// ë‚´ë¦¼ì°¨ìˆœ
sort(v.begin(), v.end(), greater<int>());
// ë˜ëŠ”
sort(v.rbegin(), v.rend());

// ëŒë‹¤ í•¨ìˆ˜ ì‚¬ìš©
sort(v.begin(), v.end(), [](int a, int b) {
    return a > b; // ë‚´ë¦¼ì°¨ìˆœ
});
```

---

## í•µì‹¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ë°˜ë“œì‹œ ìˆ™ì§€í•´ì•¼ í•  ê²ƒë“¤

#### 1. ì¬ê·€ (Recursion)
- [ ] íŠ¸ë¦¬ DFS ìˆœíšŒ (ì „ìœ„, ì¤‘ìœ„, í›„ìœ„)
- [ ] Quad Tree ì¸ì½”ë”©/ë””ì½”ë”©
- [ ] ë¶€í•˜ ìˆ˜ ê³„ì‚° (ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸°)
- [ ] ì¬ê·€ ì¢…ë£Œ ì¡°ê±´ ëª…í™•íˆ í•˜ê¸°

#### 2. BST ì—°ì‚°
- [ ] ì‚½ì… (Insert)
- [ ] **ì‚­ì œ (Delete) - ì™¼ìª½ ìµœëŒ€/ì˜¤ë¥¸ìª½ ìµœì†Œ** â­
- [ ] íƒìƒ‰ (Search)
- [ ] íŠ¹ì • depth ì°¾ê¸°
- [ ] Leaf ì°¾ê¸°
- [ ] ì¤‘ìœ„ ìˆœíšŒ â†’ ì •ë ¬ëœ ìˆœì„œ

#### 3. ê·¸ë˜í”„ íƒìƒ‰
- [ ] BFS ê¸°ë³¸ êµ¬í˜„
- [ ] **ìƒíƒœ ê³µê°„ BFS (x, y, direction)** â­â­
- [ ] ì—°ê²° ì„±ë¶„ í™•ì¸ (DFS/BFS)
- [ ] ìµœë‹¨ ê²½ë¡œ (ê°€ì¤‘ì¹˜ ìˆëŠ” ê²½ìš°)
- [ ] Queue ì‚¬ìš©ë²•

#### 4. STL í™œìš©
- [ ] `map<set<int>, vector<int>>` - setì„ keyë¡œ
- [ ] `unordered_set<string>` - ì¤‘ë³µ ì²´í¬
- [ ] `vector<vector<int>>` - 2D ë°°ì—´
- [ ] `priority_queue` (í•„ìš”ì‹œ)
- [ ] ì •ë ¬ (sort with comparator)

#### 5. ë¬¸ìì—´ ì²˜ë¦¬
- [ ] íŒŒì‹± (ê´„í˜¸ ë§¤ì¹­, ì¸ë±ìŠ¤ ê´€ë¦¬)
- [ ] `substring` ì¶”ì¶œ
- [ ] `string` â†” `int` ë³€í™˜ (`stoi`, `stoull`, `to_string`)
- [ ] ë¬¸ìì—´ ì—°ê²°

#### 6. ì‹œê°„ ë³µì¡ë„ ì´í•´
- [ ] BFS: O(V + E)
- [ ] DFS: O(V + E)
- [ ] BST ì—°ì‚°: O(log N) ~ O(N)
- [ ] Hash íƒìƒ‰: O(1) í‰ê· 

---

## ë¬¸ì œë³„ í•µì‹¬ ì•Œê³ ë¦¬ì¦˜

| ë¬¸ì œ | í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ | ì£¼ìš” ìë£Œêµ¬ì¡° | ë‚œì´ë„ | Token ì œí•œ |
|-----|------------|-------------|--------|-----------|
| 16. Complexity | ìŠ¤íƒ/ì¬ê·€ (ê´„í˜¸ ë§¤ì¹­) | Stack, Tree | â­â­ | ì—†ìŒ |
| 17. Mafia | íŠ¸ë¦¬ DFS, ë‹¤ë‹¨ê³„ ì •ë ¬ | Tree, Vector | â­â­â­ | 650 |
| 18. Quad Tree | ì¬ê·€ ì¸ì½”ë”©/ë””ì½”ë”©, íŒŒì‹± | Quad Tree | â­â­â­â­ | 700 |
| 19. BTS | BST ì‚½ì…/ì‚­ì œ, íŠ¸ë¦¬ ìˆœíšŒ | BST | â­â­â­â­ | 700 |
| 21. Party | BFSÃ—3, ìµœì†Œê°’ ì°¾ê¸° | Graph, Queue | â­â­â­â­ | 650 |
| 22. Delivery Robot | **ìƒíƒœ ê³µê°„ BFS** | Graph, Queue | â­â­â­â­â­ | 700 |
| 24. GDBC | map<set, vector>, ì •ë ¬ | Map, Set | â­â­â­â­ | 500 |
| 25. Giftcode | í•´ì‹±, set ì¤‘ë³µ ì²´í¬ | Hash, Set | â­â­â­ | 700 |

---

## ê³µë¶€ ìˆœì„œ ì¶”ì²œ

### ğŸ”° ì´ˆê¸‰ (ê¸°ì´ˆ ë‹¤ì§€ê¸°)
1. **16. Complexity** - ìŠ¤íƒ/ì¬ê·€ ê¸°ì´ˆ
2. **25. Giftcode** - í•´ì‹± ê¸°ì´ˆ, set ì‚¬ìš©ë²•

### ğŸ”¸ ì¤‘ê¸‰ (íŠ¸ë¦¬ ë§ˆìŠ¤í„°)
3. **17. Mafia** - íŠ¸ë¦¬ ìˆœíšŒ, ì •ë ¬
4. **19. BTS** - BST ì‚­ì œ (ì¤‘ìš”!)

### ğŸ”¥ ê³ ê¸‰ (ê·¸ë˜í”„ ì‹¬í™”)
5. **21. Party** - BFS ê¸°ë³¸
6. **24. GDBC** - map<set> í™œìš©

### ğŸ’€ ìµœê³ ê¸‰ (ëíŒì™•)
7. **18. Quad Tree** - ì¬ê·€ íŒŒì‹±
8. **22. Delivery Robot** - ìƒíƒœ ê³µê°„ BFS (ê°€ì¥ ì–´ë ¤ì›€!)

---

## íŒ & ì£¼ì˜ì‚¬í•­

### ğŸ’¡ ì½”ë”© íŒ

1. **ì…ì¶œë ¥ ìµœì í™”**
   ```cpp
   ios_base::sync_with_stdio(false);
   cin.tie(nullptr);
   ```

2. **ë””ë²„ê¹…**
   ```cpp
   #ifdef LOCAL
   freopen("input.txt", "r", stdin);
   #endif
   ```

3. **ë²”ìœ„ ì²´í¬**
   - ë°°ì—´ ì¸ë±ìŠ¤ ë²”ìœ„
   - NULL í¬ì¸í„° ì²´í¬
   - ì—£ì§€ ì¼€ì´ìŠ¤ (N=1, ë¹ˆ íŠ¸ë¦¬ ë“±)

4. **ë©”ëª¨ë¦¬ ê´€ë¦¬**
   - `new`ë¡œ í• ë‹¹í•˜ë©´ `delete` í•„ìˆ˜
   - ë˜ëŠ” ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš©

### âš ï¸ ì£¼ì˜ì‚¬í•­

1. **Depth ì‹œì‘ê°’ í™•ì¸** (0 or 1)
2. **ì‚¬ì „ìˆœ ì •ë ¬** ì‹œ ëŒ€ì†Œë¬¸ì êµ¬ë¶„
3. **ì¤‘ë³µ ì²˜ë¦¬** - set ì‚¬ìš© ë˜ëŠ” ì¤‘ë³µ ì²´í¬
4. **ì…ë ¥ ì¢…ë£Œ ì¡°ê±´** - `quit`, `$`, `0` ë“±
5. **ì¶œë ¥ í˜•ì‹** - ê³µë°±, ì¤„ë°”ê¿ˆ ì •í™•íˆ

---

## ë§ˆë¬´ë¦¬

### ğŸ¯ ì‹œí—˜ ì „ ìµœì¢… ì²´í¬

- [ ] ëª¨ë“  ê¸°ë³¸ ìë£Œêµ¬ì¡° êµ¬í˜„ ê°€ëŠ¥
- [ ] BST ì‚­ì œ ë¡œì§ ì™„ë²½ ì´í•´
- [ ] BFS (ê¸°ë³¸ + ìƒíƒœ ê³µê°„) êµ¬í˜„ ê°€ëŠ¥
- [ ] map<set>, unordered_set ì‚¬ìš©ë²•
- [ ] ì¬ê·€ í•¨ìˆ˜ ì‘ì„± ëŠ¥ìˆ™
- [ ] ë‹¤ë‹¨ê³„ ì •ë ¬ êµ¬í˜„ ê°€ëŠ¥
- [ ] ë¬¸ìì—´ íŒŒì‹±/ì²˜ë¦¬ ëŠ¥ìˆ™

### ğŸ”¥ í™”ì´íŒ…!

**"í•œ ë¬¸ì œ í•œ ë¬¸ì œ ì°¨ê·¼ì°¨ê·¼, ë°˜ë“œì‹œ ì •ë³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"**

---

ğŸ“ **ì‘ì„±ì¼**: 2025-12-15
ğŸ“š **ê³¼ëª©**: ìë£Œêµ¬ì¡°
ğŸ“ **í•™êµ**: ë¶€ì‚°ëŒ€í•™êµ CSED
---

## 8. Priority Queue (ìš°ì„ ìˆœìœ„ í)

### 8.1 ê°œë…

**ìš°ì„ ìˆœìœ„ í**ëŠ” ì¼ë°˜ íì™€ ë‹¬ë¦¬, **ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì›ì†Œ**ê°€ ë¨¼ì € ë‚˜ì˜¤ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

| êµ¬ë¶„ | ì¼ë°˜ Queue | Priority Queue |
|-----|-----------|----------------|
| **ìˆœì„œ** | FIFO (ë¨¼ì € ë“¤ì–´ê°„ ê²ƒì´ ë¨¼ì € ë‚˜ì˜´) | **ìš°ì„ ìˆœìœ„** ìˆœ |
| **ì‚¬ìš© ì˜ˆ** | BFS | Dijkstra, A* |
| **STL** | `queue<T>` | `priority_queue<T>` |

### 8.2 ê¸°ë³¸ ì‚¬ìš©ë²•

```cpp
#include <queue>
using namespace std;

// ê¸°ë³¸ (ìµœëŒ€ í™ - í° ê°’ì´ ë¨¼ì €)
priority_queue<int> pq;
pq.push(5);
pq.push(2);
pq.push(8);
cout << pq.top();  // 8 (ê°€ì¥ í° ê°’)
pq.pop();
cout << pq.top();  // 5

// ìµœì†Œ í™ (ì‘ì€ ê°’ì´ ë¨¼ì €) - ë§ì´ ì‚¬ìš©!
priority_queue<int, vector<int>, greater<int>> pq_min;
pq_min.push(5);
pq_min.push(2);
pq_min.push(8);
cout << pq_min.top();  // 2 (ê°€ì¥ ì‘ì€ ê°’)
```

### 8.3 êµ¬ì¡°ì²´ì™€ í•¨ê»˜ ì‚¬ìš©

```cpp
struct State {
    int cost, x, y;
    
    // greater<State>ë¥¼ ìœ„í•œ ë¹„êµ ì—°ì‚°ì
    bool operator>(const State& other) const {
        return cost > other.cost;  // costê°€ ì‘ì€ ê²ƒì´ ìš°ì„ 
    }
};

// costê°€ ì‘ì€ ê²ƒë¶€í„° ë‚˜ì˜´
priority_queue<State, vector<State>, greater<State>> pq;
pq.push({10, 1, 2});
pq.push({5, 3, 4});
pq.push({15, 5, 6});

State top = pq.top();  // {5, 3, 4} (cost=5ê°€ ê°€ì¥ ì‘ìŒ)
```

### 8.4 ì–¸ì œ ì‚¬ìš©í•˜ë‚˜?

#### Queue (ì¼ë°˜ í) ì‚¬ìš©
```cpp
// ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ê°™ì„ ë•Œ
queue<int> q;
```
- ê¸°ë³¸ BFS
- ëª¨ë“  ì´ë™ ë¹„ìš©ì´ 1ì¼ ë•Œ

#### Priority Queue (ìš°ì„ ìˆœìœ„ í) ì‚¬ìš©
```cpp
// ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ë‹¤ë¥¼ ë•Œ
priority_queue<State, vector<State>, greater<State>> pq;
```
- Dijkstra (ìµœë‹¨ ê²½ë¡œ)
- A* ì•Œê³ ë¦¬ì¦˜
- **ë¹„ìš©ì´ ë‹¤ë¥¸ BFS**

### 8.5 22ë²ˆ ë¬¸ì œì—ì„œ

```cpp
// ì›ë³¸ (priority_queue ì‚¬ìš©)
priority_queue<State, vector<State>, greater<State>> pq;

// ì™œ? 
// - ì§ì§„: ë¹„ìš© 1
// - íšŒì „: ë¹„ìš© t (2~5)
// ë¹„ìš©ì´ ë‹¤ë¥´ë¯€ë¡œ ì‘ì€ ë¹„ìš©ë¶€í„° ì²˜ë¦¬í•˜ëŠ” ê²Œ íš¨ìœ¨ì !
```

í•˜ì§€ë§Œ **ì¼ë°˜ queueë¡œë„ ê°€ëŠ¥!**

```cpp
// ì¼ë°˜ queue ë²„ì „
queue<State> q;

// dist ë°°ì—´ë¡œ ìµœì†Œê°’ ê°±ì‹ 
if (newCost < dist[ny][nx][dir]) {
    dist[ny][nx][dir] = newCost;
    q.push({nx, ny, dir, newCost});
}

// ì²˜ë¦¬í•  ë•Œ ì²´í¬
if (cur.cost > dist[cur.y][cur.x][cur.dir]) continue;
```

### 8.6 Queue vs Priority Queue ë¹„êµ

```cpp
// ì˜ˆì‹œ: (1,1) â†’ (3,3)ë¡œ ê°€ëŠ”ë°
// - ì§ì§„: ë¹„ìš© 1
// - íšŒì „: ë¹„ìš© 3

// Priority Queue
pqì— ë“¤ì–´ìˆëŠ” ìˆœì„œ: {ë¹„ìš©1, ...}, {ë¹„ìš©2, ...}, {ë¹„ìš©4, ...}
ì²˜ë¦¬ ìˆœì„œ: ë¹„ìš©1 â†’ ë¹„ìš©2 â†’ ë¹„ìš©4
íš¨ìœ¨ì ! âœ…

// ì¼ë°˜ Queue  
qì— ë“¤ì–´ìˆëŠ” ìˆœì„œ: {ë¹„ìš©4, ...}, {ë¹„ìš©1, ...}, {ë¹„ìš©2, ...}
ì²˜ë¦¬ ìˆœì„œ: ë¹„ìš©4 â†’ ë¹„ìš©1 â†’ ë¹„ìš©2
ë¹„íš¨ìœ¨ì ì´ì§€ë§Œ, dist ë°°ì—´ ì²´í¬ë¡œ ê·¹ë³µ ê°€ëŠ¥! âœ…
```

### 8.7 ê²°ë¡ 

| ìƒí™© | ì‚¬ìš©í•  ê²ƒ | ì´ìœ  |
|-----|----------|------|
| **ë¹„ìš©ì´ ëª¨ë‘ ê°™ìŒ** | `queue` | ê°„ë‹¨í•˜ê³  ë¹ ë¦„ |
| **ë¹„ìš©ì´ ë‹¤ë¦„** | `priority_queue` | íš¨ìœ¨ì  |
| **priority_queue ëª¨ë¦„** | `queue` + dist ì²´í¬ | ê°€ëŠ¥! (ì•½ê°„ ëŠë¦´ ìˆ˜ ìˆìŒ) |

**22ë²ˆ ë¬¸ì œ**: ë‘˜ ë‹¤ ê°€ëŠ¥! í¸í•œ ê±¸ë¡œ í•˜ì„¸ìš”! ğŸ˜

---

## 9. Deep Map (ë‹¤ì°¨ì› Map)

### 9.1 Deep Mapì´ë€?

**Deep Map**ì€ map ì•ˆì— ë˜ ë‹¤ë¥¸ mapì´ ë“¤ì–´ìˆëŠ” **ì¤‘ì²©ëœ(nested) map** êµ¬ì¡°ì…ë‹ˆë‹¤.

```cpp
// 1D Map (ì¼ë°˜ map)
map<int, string> normal_map;

// 2D Map (Deep Map)
map<int, map<int, string>> deep_map_2d;

// 3D Map (ë” ê¹Šì€ Deep Map)
map<int, map<int, map<int, string>>> deep_map_3d;
```

**ì‚¬ìš© ì˜ˆì‹œ**:
- 2D ì¢Œí‘œ (x, y) â†’ ê°’ ë§¤í•‘
- í•™ìƒ ID + ê³¼ëª© ID â†’ ì„±ì  ë§¤í•‘
- ë‚ ì§œ + ì‹œê°„ â†’ ì´ë²¤íŠ¸ ë§¤í•‘

### 9.2 2D Map ê¸°ë³¸ ì‚¬ìš©ë²•

#### ì„ ì–¸ ë° ê°’ í• ë‹¹

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    // 2D Map ì„ ì–¸: map<ì™¸ë¶€keyíƒ€ì…, map<ë‚´ë¶€keyíƒ€ì…, valueíƒ€ì…>>
    map<int, map<int, int>> mymap;

    // ê°’ í• ë‹¹ (ë§¤ìš° ê°„ë‹¨!)
    mymap[8][2] = 17;
    mymap[7][3] = 37;
    mymap[9][5] = 57;
    mymap[9][99] = -7;

    // ê°’ ì ‘ê·¼
    cout << "mymap[9][5] = " << mymap[9][5] << endl;  // 57

    return 0;
}
```

**ì¤‘ìš”**: `mymap[x][y] = value;` ì²˜ëŸ¼ **2ì°¨ì› ë°°ì—´ì²˜ëŸ¼** ì‚¬ìš© ê°€ëŠ¥!

#### ê°’ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (find ì‚¬ìš©) â­

```cpp
int x = 9, y = 8;

// ì˜ëª»ëœ ë°©ë²• âŒ
if (mymap[x][y] != 0) { ... }  // ê°’ì´ ì—†ì–´ë„ ìë™ìœ¼ë¡œ 0ì„ ìƒì„±í•¨!

// ì˜¬ë°”ë¥¸ ë°©ë²• âœ…
if (mymap.find(x) != mymap.end() && mymap[x].find(y) != mymap[x].end()) {
    cout << "mymap[" << x << "][" << y << "] = " << mymap[x][y] << endl;
} else {
    cout << "ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤." << endl;
}
```

**í•µì‹¬**:
1. ë¨¼ì € `mymap.find(x)`ë¡œ **ì™¸ë¶€ key** í™•ì¸
2. ê·¸ ë‹¤ìŒ `mymap[x].find(y)`ë¡œ **ë‚´ë¶€ key** í™•ì¸
3. ë‘˜ ë‹¤ ì¡´ì¬í•˜ë©´ ê°’ ì ‘ê·¼

### 9.3 Iteratorë¡œ ìˆœíšŒí•˜ê¸°

#### ë°©ë²• 1: Range-based for (C++11) - ì¶”ì²œ! â­

```cpp
map<int, map<int, string>> w;
w[1][5] = "Buchman";
w[-1][9] = "Sosa";
w[4][2] = "Pepe";
w[9][-3] = "Delilar";

// ì™¸ë¶€ map ìˆœíšŒ
for (auto p : w) {
    int outer_key = p.first;
    map<int, string>& inner_map = p.second;  // ë‚´ë¶€ map (ì°¸ì¡°!)

    // ë‚´ë¶€ map ìˆœíšŒ
    for (auto it2 : inner_map) {
        int inner_key = it2.first;
        string value = it2.second;

        cout << "w[" << outer_key << "][" << inner_key << "] = " << value << endl;
    }
}
```

**ì¶œë ¥**:
```
w[-1][9] = Sosa
w[1][5] = Buchman
w[4][2] = Pepe
w[9][-3] = Delilar
```

#### ë°©ë²• 2: Iterator ì§ì ‘ ì‚¬ìš©

```cpp
map<int, map<int, string>> w;
// ... ë°ì´í„° ì…ë ¥

for (auto it = w.begin(); it != w.end(); it++) {
    int outer_key = it->first;
    map<int, string>& inner_map = it->second;

    for (auto it2 = inner_map.begin(); it2 != inner_map.end(); it2++) {
        cout << "w[" << outer_key << "][" << it2->first << "] = "
             << it2->second << endl;
    }
}
```

### 9.4 3D Map (ë” ê¹Šì€ ì¤‘ì²©)

```cpp
// 3D Map ì„ ì–¸
map<string, map<string, map<int, float>>> deep3d;

// ê°’ í• ë‹¹
deep3d["Seoul"]["Gangnam"][2023] = 12.5;
deep3d["Seoul"]["Gangnam"][2024] = 15.7;
deep3d["Busan"]["Haeundae"][2023] = 8.3;

// ê°’ ì ‘ê·¼
cout << deep3d["Seoul"]["Gangnam"][2024] << endl;  // 15.7

// ìˆœíšŒ
for (auto city : deep3d) {
    for (auto district : city.second) {
        for (auto year_data : district.second) {
            cout << city.first << " " << district.first << " "
                 << year_data.first << ": " << year_data.second << endl;
        }
    }
}
```

### 9.5 Deep Map vs Pairë¥¼ Keyë¡œ ì‚¬ìš©

ê°™ì€ ëª©ì ì„ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œë„ êµ¬í˜„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

#### ë°©ë²• 1: Deep Map

```cpp
map<int, map<int, string>> deep_map;
deep_map[10][20] = "Apple";
deep_map[10][30] = "Banana";

// ì¥ì : 2D ë°°ì—´ì²˜ëŸ¼ ì§ê´€ì 
// ë‹¨ì : ë©”ëª¨ë¦¬ ì•½ê°„ ë” ì‚¬ìš©, ë³µì¡í•¨
```

#### ë°©ë²• 2: Pairë¥¼ Keyë¡œ

```cpp
map<pair<int, int>, string> pair_map;
pair_map[{10, 20}] = "Apple";
pair_map[{10, 30}] = "Banana";

// ì¥ì : ë‹¨ìˆœí•˜ê³  íš¨ìœ¨ì 
// ë‹¨ì : 2D ìˆœíšŒê°€ ë¶ˆí¸í•¨
```

**ì–¸ì œ ì‚¬ìš©?**
- **Deep Map**: xì¢Œí‘œë³„ë¡œ ë¬¶ì–´ì„œ ì²˜ë¦¬í•  ë•Œ
- **Pair Map**: ë‹¨ìˆœíˆ 2D ì¢Œí‘œë§Œ ì €ì¥í•  ë•Œ

### 9.6 ì‹¤ì „ ì˜ˆì œ: ì¢Œí‘œ í‰ë©´ ê´€ë¦¬

```cpp
#include <map>
#include <iostream>
using namespace std;

int main() {
    // 2D ì¢Œí‘œ í‰ë©´ì— ê°’ ì €ì¥
    map<int, map<int, string>> grid;

    // ì—¬ëŸ¬ ì¢Œí‘œì— ê°’ í• ë‹¹
    grid[0][0] = "Origin";
    grid[1][2] = "Point A";
    grid[-3][4] = "Point B";
    grid[5][-2] = "Point C";

    // íŠ¹ì • ì¢Œí‘œ ê²€ìƒ‰
    int x = 1, y = 2;
    if (grid.find(x) != grid.end() && grid[x].find(y) != grid[x].end()) {
        cout << "ì¢Œí‘œ (" << x << ", " << y << ")ì— "
             << grid[x][y] << "ì´(ê°€) ìˆìŠµë‹ˆë‹¤." << endl;
    }

    // x=1ì¸ ëª¨ë“  ì  ì¶œë ¥
    if (grid.find(1) != grid.end()) {
        cout << "\nx=1ì¸ ì ë“¤:" << endl;
        for (auto p : grid[1]) {
            cout << "  (1, " << p.first << ") = " << p.second << endl;
        }
    }

    // ì „ì²´ ìˆœíšŒ
    cout << "\nì „ì²´ ì¢Œí‘œ:" << endl;
    for (auto row : grid) {
        for (auto cell : row.second) {
            cout << "  (" << row.first << ", " << cell.first
                 << ") = " << cell.second << endl;
        }
    }

    return 0;
}
```

**ì¶œë ¥**:
```
ì¢Œí‘œ (1, 2)ì— Point Aì´(ê°€) ìˆìŠµë‹ˆë‹¤.

x=1ì¸ ì ë“¤:
  (1, 2) = Point A

ì „ì²´ ì¢Œí‘œ:
  (-3, 4) = Point B
  (0, 0) = Origin
  (1, 2) = Point A
  (5, -2) = Point C
```

### 9.7 ì‹¤ì „ ì˜ˆì œ: í•™ìƒ ì„±ì  ê´€ë¦¬

```cpp
#include <map>
#include <string>
#include <iostream>
using namespace std;

int main() {
    // map<í•™ìƒID, map<ê³¼ëª©ì½”ë“œ, ì ìˆ˜>>
    map<int, map<string, int>> grades;

    // ì„±ì  ì…ë ¥
    grades[20231001]["Math"] = 95;
    grades[20231001]["English"] = 88;
    grades[20231001]["CS"] = 92;

    grades[20231002]["Math"] = 78;
    grades[20231002]["English"] = 85;

    grades[20231003]["Math"] = 100;

    // íŠ¹ì • í•™ìƒì˜ íŠ¹ì • ê³¼ëª© ì„±ì  ì¡°íšŒ
    int student_id = 20231001;
    string subject = "Math";

    if (grades.find(student_id) != grades.end() &&
        grades[student_id].find(subject) != grades[student_id].end()) {
        cout << "í•™ìƒ " << student_id << "ì˜ " << subject
             << " ì„±ì : " << grades[student_id][subject] << endl;
    }

    // íŠ¹ì • í•™ìƒì˜ ëª¨ë“  ê³¼ëª© ì„±ì  ì¶œë ¥
    cout << "\ní•™ìƒ " << student_id << "ì˜ ì „ì²´ ì„±ì :" << endl;
    for (auto grade : grades[student_id]) {
        cout << "  " << grade.first << ": " << grade.second << endl;
    }

    // ì „ì²´ í•™ìƒ ì„±ì  í†µê³„
    cout << "\nì „ì²´ ì„±ì :" << endl;
    for (auto student : grades) {
        cout << "í•™ìƒ " << student.first << ":" << endl;
        for (auto grade : student.second) {
            cout << "  " << grade.first << ": " << grade.second << endl;
        }
    }

    return 0;
}
```

### 9.8 ì£¼ì˜ì‚¬í•­ âš ï¸

#### 1. operator[] ìë™ ìƒì„± ë¬¸ì œ

```cpp
map<int, map<int, int>> m;

// ë¬¸ì œ: ê°’ì´ ì—†ì–´ë„ ìë™ìœ¼ë¡œ ìƒì„±ë¨!
cout << m[100][200] << endl;  // 0 ì¶œë ¥, í•˜ì§€ë§Œ m[100][200]ì´ ìƒì„±ë¨!

// í•´ê²°: findë¡œ í™•ì¸
if (m.find(100) != m.end() && m[100].find(200) != m[100].end()) {
    cout << m[100][200] << endl;
}
```

#### 2. ì°¸ì¡° ì‚¬ìš©ìœ¼ë¡œ íš¨ìœ¨ ë†’ì´ê¸°

```cpp
// ë¹„íš¨ìœ¨ì  âŒ (ë§¤ë²ˆ ë³µì‚¬)
for (auto inner : m) {
    for (auto item : inner.second) {
        // ...
    }
}

// íš¨ìœ¨ì  âœ… (ì°¸ì¡° ì‚¬ìš©)
for (auto& inner : m) {
    for (auto& item : inner.second) {
        // ...
    }
}
```

#### 3. ì •ë ¬ ìˆœì„œ

```cpp
map<int, map<int, string>> m;
m[3][1] = "A";
m[1][2] = "B";
m[2][3] = "C";

// mapì€ key ê¸°ì¤€ ìë™ ì •ë ¬!
// ìˆœíšŒ ìˆœì„œ: (1,2), (2,3), (3,1)
```

### 9.9 ë©”ì„œë“œ ì •ë¦¬

| ë©”ì„œë“œ | ì„¤ëª… | ì˜ˆì‹œ |
|--------|------|------|
| `[]` | ê°’ ì ‘ê·¼/í• ë‹¹ (ì—†ìœ¼ë©´ ìƒì„±) | `m[x][y] = 10;` |
| `find()` | key ì¡´ì¬ ì—¬ë¶€ í™•ì¸ | `m.find(x) != m.end()` |
| `begin()` | ì²« iterator | `for(auto it=m.begin(); ...)` |
| `end()` | ë iterator | `it != m.end()` |
| `size()` | ì›ì†Œ ê°œìˆ˜ | `m.size()` |
| `empty()` | ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ | `if(m.empty())` |
| `clear()` | ëª¨ë“  ì›ì†Œ ì œê±° | `m.clear();` |
| `erase(key)` | íŠ¹ì • key ì œê±° | `m.erase(x);` |

### 9.10 ê¸°ë§ê³ ì‚¬ ëŒ€ë¹„ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] 2D Map ì„ ì–¸ ë° ê°’ í• ë‹¹ ê°€ëŠ¥
- [ ] `find()`ë¡œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ì¤‘ìš”!)
- [ ] Iterator/Range-based forë¡œ ìˆœíšŒ
- [ ] `[]` ì—°ì‚°ìì˜ ìë™ ìƒì„± ë™ì‘ ì´í•´
- [ ] 3D Mapë„ ê°™ì€ ì›ë¦¬ë¡œ í™•ì¥ ê°€ëŠ¥
- [ ] Pairë¥¼ Keyë¡œ ì‚¬ìš©í•˜ëŠ” ëŒ€ì•ˆë„ ì•Œê¸°

### 9.11 ìì£¼í•˜ëŠ” ì‹¤ìˆ˜ âŒ â†’ âœ…

```cpp
map<int, map<int, int>> m;

// ì‹¤ìˆ˜ 1: ì¡´ì¬ í™•ì¸ ì—†ì´ ì ‘ê·¼
if (m[x][y] > 0) { ... }  // âŒ ì—†ì–´ë„ ìƒì„±ë¨!
// ì˜¬ë°”ë¥¸ ë°©ë²•
if (m.find(x) != m.end() && m[x].find(y) != m[x].end() && m[x][y] > 0) { ... }  // âœ…

// ì‹¤ìˆ˜ 2: ê°’ ë³µì‚¬
for (auto inner : m) { ... }  // âŒ ë³µì‚¬ ë°œìƒ
// ì˜¬ë°”ë¥¸ ë°©ë²•
for (auto& inner : m) { ... }  // âœ… ì°¸ì¡° ì‚¬ìš©

// ì‹¤ìˆ˜ 3: first/second í˜¼ë™
for (auto p : m) {
    cout << p.first;   // âœ… ì™¸ë¶€ key
    cout << p.second;  // âŒ ì´ê±´ map<int,int>ì„! ê°’ì´ ì•„ë‹˜!

    for (auto p2 : p.second) {
        cout << p2.first;   // âœ… ë‚´ë¶€ key
        cout << p2.second;  // âœ… ì‹¤ì œ ê°’
    }
}
```

### 9.12 ê¸°ë§ê³ ì‚¬ìš© í•µì‹¬ ì˜ˆì œ â­â­â­

#### ì˜ˆì œ 1: 2D Map ë‚´ë¶€ êµ¬ì¡° ì´í•´ ë° ìˆœíšŒ

**ì¤‘ìš”**: ê¸°ë§ê³ ì‚¬ì— ìœ ì‚¬í•œ ë¬¸ì œ ì¶œì œ ê°€ëŠ¥!

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    map<int, map<int, string>> w;

    // ê°’ í• ë‹¹
    w[1][5] = "Buchman";
    w[-1][9] = "Sosa";
    w[4][2] = "Pepe";
    w[9][-3] = "Delilar";
    w[0][7] = "Andro";
    w[-8][2] = "Bushmill";
    w[9][6] = "Dorian";
    w[-8][5] = "Arnnoc";
    w[9][6] = "Beronika";   // â­ ì¤‘ë³µ! w[9][6]ì€ "Dorian" â†’ "Beronika"ë¡œ ë®ì–´ì”€
    w[1][0] = "Amanda";
    w[9][-3] = "Quaga";     // â­ ì¤‘ë³µ! w[9][-3]ì€ "Delilar" â†’ "Quaga"ë¡œ ë®ì–´ì”€

    // ì „ì²´ ìˆœíšŒ (ì¤‘ìš”! â­)
    for (auto p : w) {
        // p.first = ì™¸ë¶€ key (int)
        // p.second = ë‚´ë¶€ map (map<int, string>)

        map<int, string>& inner_map = p.second;  // ì°¸ì¡°ë¡œ ë°›ê¸°!

        for (auto it2 : inner_map) {
            // it2.first = ë‚´ë¶€ key (int)
            // it2.second = ê°’ (string)
            cout << "w[" << p.first << "," << it2.first << "] = "
                 << it2.second << "\n";
        }
    }

    return 0;
}
```

**ì¶œë ¥** (key ìˆœì„œëŒ€ë¡œ ìë™ ì •ë ¬):
```
w[-8,2] = Bushmill
w[-8,5] = Arnnoc
w[-1,9] = Sosa
w[0,7] = Andro
w[1,0] = Amanda
w[1,5] = Buchman
w[4,2] = Pepe
w[9,-3] = Quaga        â† "Delilar"ê°€ ì•„ë‹˜! ë§ˆì§€ë§‰ ê°’ìœ¼ë¡œ ë®ì–´ì”€
w[9,6] = Beronika      â† "Dorian"ì´ ì•„ë‹˜! ë§ˆì§€ë§‰ ê°’ìœ¼ë¡œ ë®ì–´ì”€
```

**í•µì‹¬ í¬ì¸íŠ¸**:
1. âœ… **ì°¸ì¡°(`&`) ì‚¬ìš©**: `map<int, string>& inner_map = p.second;`
   - ì°¸ì¡° ì—†ì´ í•˜ë©´ ë³µì‚¬ê°€ ì¼ì–´ë‚˜ì„œ ë¹„íš¨ìœ¨ì 
2. âœ… **ì¤‘ë³µ key ì²˜ë¦¬**: ê°™ì€ keyì— ì—¬ëŸ¬ ë²ˆ í• ë‹¹í•˜ë©´ **ë§ˆì§€ë§‰ ê°’**ì´ ì €ì¥ë¨
3. âœ… **ìë™ ì •ë ¬**: mapì€ key ê¸°ì¤€ìœ¼ë¡œ ìë™ ì •ë ¬ (ìŒìˆ˜ë„ ê°€ëŠ¥)
4. âœ… **ì´ì¤‘ ìˆœíšŒ**: ì™¸ë¶€ map ìˆœíšŒ â†’ ë‚´ë¶€ map ìˆœíšŒ

#### ì˜ˆì œ 2: ì‹¤ìƒí™œ ì‘ìš© (PNU ìº í¼ìŠ¤ ê±´ë¬¼ ìœ„ì¹˜)

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    // 2D ì¢Œí‘œ â†’ ê±´ë¬¼ëª… ë§¤í•‘
    map<int, map<int, string>> PNU_map;

    // ê±´ë¬¼ ìœ„ì¹˜ ë“±ë¡ (x, y ì¢Œí‘œ)
    PNU_map[35][5] = "ì²¨ë‹¨ê´€";
    PNU_map[3][12] = "ì •ë³´ê´€";
    PNU_map[5][12] = "ì¤‘ì•™ë„ì„œê´€";
    PNU_map[34][67] = "ë³¸ê´€";
    PNU_map[2][1] = "ì²´ìœ¡ê´€";
    PNU_map[-23][-29] = "ë¶€ì‚°ì—­";  // â­ ìŒìˆ˜ ì¢Œí‘œë„ ê°€ëŠ¥!

    // íŠ¹ì • ìœ„ì¹˜ ì¡°íšŒ
    int x, y;

    x = 3; y = 12;
    cout << "ì¢Œí‘œ (" << x << "," << y << ") = "
         << PNU_map[x][y] << "\n";  // ì •ë³´ê´€

    x = -23; y = -29;
    cout << "ì¢Œí‘œ (" << x << "," << y << ") = "
         << PNU_map[x][y] << "\n";  // ë¶€ì‚°ì—­

    return 0;
}
```

**ì¶œë ¥**:
```
ì¢Œí‘œ (3,12) = ì •ë³´ê´€
ì¢Œí‘œ (-23,-29) = ë¶€ì‚°ì—­
```

**í•µì‹¬ í¬ì¸íŠ¸**:
1. âœ… **ìŒìˆ˜ ì¢Œí‘œ**: mapì€ ìŒìˆ˜ keyë„ ì‚¬ìš© ê°€ëŠ¥
2. âœ… **ì§ê´€ì  ì ‘ê·¼**: `PNU_map[x][y]`ë¡œ 2D ë°°ì—´ì²˜ëŸ¼ ì‚¬ìš©
3. âœ… **ì‹¤ìš©ì  ì‘ìš©**: ì¢Œí‘œ â†’ ì •ë³´ ë§¤í•‘ì— ìœ ìš©

### 9.13 ê¸°ë§ê³ ì‚¬ ëŒ€ë¹„ í•µì‹¬ ì •ë¦¬ ğŸ”¥

#### ë°˜ë“œì‹œ ì•Œì•„ì•¼ í•  ê²ƒ

```cpp
// 1. ì„ ì–¸
map<int, map<int, string>> m;

// 2. ê°’ í• ë‹¹ (2D ë°°ì—´ì²˜ëŸ¼)
m[x][y] = "value";

// 3. ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ë§¤ìš° ì¤‘ìš”!)
if (m.find(x) != m.end() && m[x].find(y) != m[x].end()) {
    // ê°’ì´ ì¡´ì¬í•¨
    cout << m[x][y];
}

// 4. ì´ì¤‘ ìˆœíšŒ (ê¸°ë§ê³ ì‚¬ ë‹¨ê³¨!)
for (auto p : m) {                      // ì™¸ë¶€ map ìˆœíšŒ
    map<int, string>& inner = p.second; // ì°¸ì¡°ë¡œ ë°›ê¸°!
    for (auto it : inner) {             // ë‚´ë¶€ map ìˆœíšŒ
        cout << p.first << "," << it.first << " = " << it.second;
    }
}

// 5. íŠ¹ì • ì™¸ë¶€ keyì˜ ëª¨ë“  ë‚´ë¶€ ê°’ ì¶œë ¥
if (m.find(x) != m.end()) {
    for (auto p : m[x]) {
        cout << "m[" << x << "][" << p.first << "] = " << p.second;
    }
}
```

#### ì‹œí—˜ì— ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì§ˆë¬¸ë“¤

1. **Q**: `m[x][y]`ë¡œ ì ‘ê·¼í–ˆëŠ”ë° ê°’ì´ ì—†ìœ¼ë©´?
   - **A**: ìë™ìœ¼ë¡œ ê¸°ë³¸ê°’ ìƒì„± (intëŠ” 0, stringì€ "", ...)

2. **Q**: ê°™ì€ keyì— ì—¬ëŸ¬ ë²ˆ í• ë‹¹í•˜ë©´?
   - **A**: ë§ˆì§€ë§‰ ê°’ìœ¼ë¡œ ë®ì–´ì”€ (ì˜ˆ: `m[1][2]="A"; m[1][2]="B";` â†’ "B" ì €ì¥)

3. **Q**: ìˆœíšŒ ìˆœì„œëŠ”?
   - **A**: Key ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ (ìŒìˆ˜ < 0 < ì–‘ìˆ˜)

4. **Q**: `auto` vs `auto&`ì˜ ì°¨ì´ëŠ”?
   - **A**: `auto`ëŠ” ë³µì‚¬, `auto&`ëŠ” ì°¸ì¡° (ì°¸ì¡°ê°€ íš¨ìœ¨ì !)

5. **Q**: ìŒìˆ˜ key ì‚¬ìš© ê°€ëŠ¥?
   - **A**: ê°€ëŠ¥! `m[-10][-20] = "value";`

#### ê¸°ë§ê³ ì‚¬ ì˜ˆìƒ ë¬¸ì œ ìœ í˜•

```cpp
// ìœ í˜• 1: ê°’ í• ë‹¹ í›„ ì¶œë ¥
map<int, map<int, int>> m;
m[1][2] = 10;
m[1][3] = 20;
m[2][1] = 30;
// Q: mì„ ìˆœíšŒí•˜ë©° ì¶œë ¥í•˜ì‹œì˜¤

// ìœ í˜• 2: íŠ¹ì • ì¡°ê±´ ê²€ìƒ‰
// Q: xì¢Œí‘œê°€ 1ì¸ ëª¨ë“  ì ì˜ yì¢Œí‘œ í•©ì„ êµ¬í•˜ì‹œì˜¤

// ìœ í˜• 3: ì¡´ì¬ ì—¬ë¶€ í™•ì¸
// Q: (x, y)ì— ê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ìˆìœ¼ë©´ ì¶œë ¥í•˜ì‹œì˜¤

// ìœ í˜• 4: ì¤‘ë³µ ì²˜ë¦¬
m[5][10] = "First";
m[5][10] = "Second";
// Q: m[5][10]ì˜ ê°’ì€? (ë‹µ: "Second")
```

---
